## Configuration

### settings

运行时的全局模式, 其中一些是全局默认值可以在XML中重写

| name                     | desc                                                         |
| ------------------------ | ------------------------------------------------------------ |
| useGeneratedKeys         | 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。 |
| mapUnderscoreToCamelCase | 实现从经典数据库列名 A_COLUMN 到驼峰式经典 Java 属性名 aColumn 的自动映射。 |
| jdbcTypeForNull          | 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 |
| defaultEnumTypeHandler   | 指定 Enum 使用的默认 `TypeHandler` 。默认org.apache.ibatis.type.EnumTypeHandler |
| logImpl                  | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。        |
| vfsImpl                  | 指定 VFS 的实现                                              |

### typeAliases 类型别名

它仅与 XML 配置相关，其存在的唯一目的是为了减少重复输入完全限定类名。通常是在配置时指定包名自动发现：mybatis.typeAliasesPackage=xxx.domain/entity

### typeHandlers 类型处理器

java type 和 jdbc type的关系处理，不太需要关注，重写时实现或扩展

 `org.apache.ibatis.type.TypeHandler`、`org.apache.ibatis.type.BaseTypeHandler`

### Handling Enums 处理枚举

提供了两种处理 EnumTypeHandler（name） 或 EnumOrdinalTypeHandler（ordinal）

（1）上述也许不满足场景， 比如存储状态整型值（直接忽略Ordinal吧）

（2）显示XML配置

```XML
<resultMap>
    <result column="roundingMode" property="roundingMode" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
</resultMap>

<insert id="insert2">
    insert into users2 (roundingMode) values (
     #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler}
    )
</insert>
```

### plugins

MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：

- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
- ParameterHandler (getParameterObject, setParameters)
- ResultSetHandler (handleResultSets, handleOutputParameters)
- StatementHandler (prepare, parameterize, batch, update, query)

### 事务管器(transactionManager)

在mybatis中有两种类型的事务管理器(type=JDBC|MANAGED)

JDBC-这个配置直接使用了JDBC的提交和回滚功能，它依赖从数据源获得的连接来管理事务的作用域。默认情况下，在关闭连接时启用自动提交

MANAGED-这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。默认情况下，它会关闭连接。

在spring+mybatis中，没有必要设置事务管理器，设置了也不会生效，spring会使用自带的事务管理器来覆盖mybatis自己的配置。

我们也可以使用TransactionTemplate来操作事务，此时可以省略commit和rollback方法的调用

```java
public class UserService {
  private final PlatformTransactionManager transactionManager;
  public UserService(PlatformTransactionManager transactionManager) {
    this.transactionManager = transactionManager;
  }
  public void createUser() {
    TransactionStatus txStatus =
        transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {
      userMapper.insertUser(user);
    } catch (Exception e) {
      transactionManager.rollback(txStatus);
      throw e;
    }
    transactionManager.commit(txStatus);
  }
}
```

在使用 `TransactionTemplate` 的时候，可以省略对 `commit` 和 `rollback` 方法的调用。

```java
public class UserService {
  private final PlatformTransactionManager transactionManager;
  public UserService(PlatformTransactionManager transactionManager) {
    this.transactionManager = transactionManager;
  }
  public void createUser() {
    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
    transactionTemplate.execute(txStatus -> {
      userMapper.insertUser(user);
      return null;
    });
  }
}
```



## 映射器 XML 文件

### XML元素

（insert and update）useGeneratedKeys

（insert and update）keyProperty

（insert and update）keyColumn（如PGSQL 第一列非Id）

```XML
<insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id">
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
</insert>
```

### 动态SQL

- if
- choose (when, otherwise)
- trim (where, set)
- foreach

```xml
<if test="name != null">
</if>

 <choose>
     <when test="title != null">...</when>
     <otherwise>...</otherwise>
</choose>

<foreach item="item" index="index" collection="list"
         open="ID in (" separator="," close=")" nullable="true">
    #{item}
</foreach>
```