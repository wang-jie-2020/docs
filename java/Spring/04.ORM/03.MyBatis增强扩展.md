## PageHelper

分页插件, 在使用时需要注意:

1. 每个查询都需要单独调用一次 `startPage()`，PageHelper 只对 **第一个查询生效**
2. 如果查询接口中有DTO转换，Count 字段要重新赋值

通过Http请求参数进行Page操作的简短例子:

```java
public class PageUtils {
    public static void startPage() {

        Integer pageNum = Integer.parseInt(getParameter("pageNum"));
        Integer pageSize = Integer.parseInt(getParameter("pageSize"));
        String orderBy = getParameter("orderByColumn");
        String asc = getParameter("isAsc");

        if(orderBy == null || "".equals(orderBy)) {
            orderBy = "";
        }

        // Reasonable参数表示是否修正传入的页码和实际页码
        PageHelper.startPage(pageNum, pageSize, orderBy.toLowerCase() + " " + asc).setReasonable(true);
    }

    public static String getParameter(String name)
    {
        return getRequest().getParameter(name);
    }

    public static HttpServletRequest getRequest()
    {
        return getRequestAttributes().getRequest();
    }

    public static ServletRequestAttributes getRequestAttributes()
    {
        RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
        return (ServletRequestAttributes) attributes;
    }
}
```



## dynamic-datasource

通过`AbstractRoutingDataSource`可以动态的指定DataSource(也许这里写Connection), 简述过程是创建自己的路由实现进行重写:

```java
@Nullable
protected abstract Object determineCurrentLookupKey();
```

RuoYi 中也是如此, 在创建DynamicDataSource Bean时传入配置中的master、slave两个Connection信息

```java
public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources)
```

重写上述方法以读TheadLocal变量来决定返回值, 通过aop 注解在具体的Service中进行数据源切换



*待查的问题: 创建了 class DynamicDataSource extends AbstractRoutingDataSource, 通过@Configuration、@Bean的方式注册了DynamicDataSource Bean之后, DataBase这个Bean的实现就指向了DynamicDataSource....*





















