# 配置使用

## 一、配置概述

| name                     | desc                                                         |
| ------------------------ | ------------------------------------------------------------ |
| useGeneratedKeys         | 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。 |
| mapUnderscoreToCamelCase | 实现从经典数据库列名 A_COLUMN 到驼峰式经典 Java 属性名 aColumn 的自动映射。 |
| defaultExecutorType      | 配置默认执行器。SIMPLE 执行器不执行任何特殊操作。REUSE 执行器重用预处理语句。BATCH 执行器重用语句并批量处理更新。默认SIMPLE。 |
| defaultEnumTypeHandler   | 指定 Enum 使用的默认 `TypeHandler` 。默认org.apache.ibatis.type.EnumTypeHandler。 |
| logImpl                  | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。        |

typeAliases 类型别名, 仅与 XML 配置相关，其存在的唯一目的是为了减少重复输入完全限定类名。

typeHandlers 类型处理器, java type 和 jdbc type的关系处理，不太需要关注，重写时实现或扩展, 在全局配置 或者 字段配置 中标注

​	#{field, typeHandler=xxxx}

enumTypeHandler 枚举类型处理器, 派生自typeHandlers, 默认提供枚举枚举和顺序, 可以考虑参考mbp中注解处理



拦截器允许在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：

- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
- ParameterHandler (getParameterObject, setParameters)
- ResultSetHandler (handleResultSets, handleOutputParameters)
- StatementHandler (prepare, parameterize, batch, update, query)

比如mbp中全表操作插件



## 二、映射器 XML 文件

### XML元素

（insert and update）useGeneratedKeys keyProperty

动态SQL:

- if
- choose (when, otherwise)
- trim (where, set)
- foreach

```xml
<if test="name != null">
</if>

 <choose>
     <when test="title != null">...</when>
     <otherwise>...</otherwise>
</choose>

<foreach item="item" index="index" collection="list"
         open="ID in (" separator="," close=")" nullable="true">
    #{item}
</foreach>
```



## 三、SqlSessionTemplate

>每个线程都应该有自己的 SqlSession 实例。SqlSession 的实例不共享，并且不是线程安全的。因此，最佳作用域是请求或方法作用域。永远不要在静态字段甚至类的实例字段中保留对 SqlSession 实例的引用。永远不要在任何类型的托管作用域中保留对 SqlSession 的引用，例如 Servlet 框架的 HttpSession。如果您使用的是任何类型的 Web 框架，请考虑 SqlSession 遵循与 HTTP 请求类似的范围。换句话说，在收到 HTTP 请求时，您可以打开一个 SqlSession，然后在返回响应后，您可以关闭它。

在未实践时的理解类似于请求内单例, 比如线程Local中空-创建-返回的模式. 包括在查找的资料中也是一笔带过的. 但仔细想想其中有问题, 比如在事务中这样干似乎不合适. 浅写了代码得到的结果是从不同方式注入的SqlSession是一样的, 但这不代表上述理解完全错误, 在Spring下实际注入的类型是SqlSessionTemplate似乎仍旧保持了单例模式, 通过不同的拦截要求自动处理了SqlSession的创建和释放

```java
public class SqlSessionTemplate implements SqlSession, DisposableBean {

    public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory,
                              ExecutorType executorType, 
                              PersistenceExceptionTranslator exceptionTranslator) {

        this.sqlSessionFactory = sqlSessionFactory;
        this.executorType = executorType;
        this.exceptionTranslator = exceptionTranslator;
        
        // here
        this.sqlSessionProxy = (SqlSession)Proxy.newProxyInstance(SqlSessionFactory.class.getClassLoader(), new Class[]{SqlSession.class}, new SqlSessionInterceptor());
    }
}
```

通过SqlSession, 进行直接的SQL使用以及其他的手动控制, 但需要注意的是默认的Executor是SimpleExecutor

### BatchExecutor

默认Executor是SimpleExecutor, 直接注入的sqlSession也指向它, 在Batch操作时如下:

```java
// 获取BATCH类型的SqlSession，false表示手动提交事务
try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, false)) {

    CrudMapper mapper = sqlSession.getMapper(CrudMapper.class);

    for (int i = 0; i < dataList.size(); i++) {
        mapper.insert(dataList.get(i));

        // 分批刷新，避免内存溢出
        if ((i + 1) % BATCH_SIZE == 0) {
            sqlSession.flushStatements(); // 刷新语句到数据库[citation:2]
        }
    }

    sqlSession.flushStatements(); // 刷新剩余的语句
    sqlSession.commit(); // 提交事务[citation:5]
}
```



## 四、TransactionTemplate

[相关资料](./事务管理概述.md), 注意@Transactional注解的问题(和其他Aspect一样):

1. 内部调用

2. 静态方法、final类或方法、private方法
3. rollback 默认只针对RuntimeException

