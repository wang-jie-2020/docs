最简实现一个过滤器:

1. 实现`Filter`接口, 如下

```java
public class doImpFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        // 过滤链路, 需要传递出去, 否则会短路
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
    }
}
```

2. 配置生效

```java
@Bean
public FilterRegistrationBean doFilterRegistration() {

    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(new doImpFilter());
    registration.addUrlPatterns("/imp/*");
    registration.setName("doImpFilter");
    registration.setOrder(FilterRegistrationBean.LOWEST_PRECEDENCE);

    return registration;
}
```



`Filter` 包含三个方法: `init`、`doFilter`、`destory`:

- init(FilterConfig filterConfig)

  filterConfig 指的是定义过滤器时传递的参数, XML配置 或者 这样:

  ```java
  @Bean
  public FilterRegistrationBean doFilterRegistration() {
  
      FilterRegistrationBean registration = new FilterRegistrationBean();
      registration.setFilter(new doImpFilter());
      registration.addUrlPatterns("/imp/*");
      registration.setName("doImpFilter");
      registration.setOrder(FilterRegistrationBean.LOWEST_PRECEDENCE);
  
      Map<String, String> initParameters = new HashMap<String, String>();
      initParameters.put("param", "1,2,3");
      registration.setInitParameters(initParameters);
  
      return registration;
  }
  ```

  

  ```java
  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
      Filter.super.init(filterConfig);
  
      String parameters = filterConfig.getInitParameter("param");
  }
  ```

  

- doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)

  通过参数 ServletRequest、ServletResponse 继续



过滤器虽然不会针对某个具体需求, 但大概率也会结合项目配置或者代码注解集合, 当需要Ioc容器相关内容的情况下, 以上的过滤器方式可以:

(1) 通过 'registration.setInitParameters()' 传递参数

(2) 通过 静态类

(3) 通过 api

```java
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

        ServletContext context = filterConfig.getServletContext();
        WebApplicationContext cxt = WebApplicationContextUtils.getWebApplicationContext(context);
    }
```

```java
HttpServletRequest request = (HttpServletRequest) servletRequest;
HttpServletResponse response = (HttpServletResponse) servletResponse;

WebApplicationContext cxt = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());
```



如此实现的过滤器并不在Spring的管理下(Filter 由 Servlet定义调用), 也存在一种代理链方式`DelegatingFilterProxy`, 相当于一个代理类，通过配置中的DelegatingFilterProxy对应的filter-name去spring的IOC容器中寻找id是filter-name的过滤器，也即是FilterChainProxy,找到之后执行DelegatingFilterProxy中对应的过滤逻辑。

![img](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/v2-e8db1153feba42975920dc7d1c33661f_720w.webp)



![image-20250724100520393](https://raw.gitcode.com/qq_36179938/images/raw/main/image-20250724100520393.png)

![image-20250724100609701](https://raw.gitcode.com/qq_36179938/images/raw/main/image-20250724100609701.png)



执行这种方式时, 只需要修改下注册方式即可正常进行依赖注入

```java
@Bean
public DelegatingFilterProxy myServletFilter() {
    return new DelegatingFilterProxy("doImpFilterProxy");
}
```

或者

```java
@Bean
public FilterRegistrationBean<DelegatingFilterProxy> doImpFilterProxyRegistration() {
    FilterRegistrationBean<DelegatingFilterProxy> registrationBean = new FilterRegistrationBean<>();
    registrationBean.setFilter(new DelegatingFilterProxy("doImpFilterProxy"));
    registrationBean.addUrlPatterns("/imp/*");
    return registrationBean;
}
```


Spring当然有对过滤器的封装, 如:

- GenericFilterBean

  是 Spring 对 javax.servlet.Filter 接口的实现，提供基础功能（如初始化、销毁方法的默认实现）。
  需要开发者手动控制过滤逻辑的执行次数，无法自动确保每个请求只执行一次。
  适用于需要灵活控制执行次数的场景（如多次记录日志或动态处理请求）。

- OncePerRequestFilter

  继承自 GenericFilterBean，核心功能是确保每个 HTTP 请求的过滤逻辑仅执行一次。
  内部通过检查请求属性（如 javax.servlet._FILTERED）或 ThreadLocal 来跟踪请求是否已处理过。
  适用于需要严格保证单次执行的场景（如认证、鉴权、流量控制等）














