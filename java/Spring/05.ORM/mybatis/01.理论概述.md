## 过程接口:

[参考资料](https://www.cnblogs.com/RunningSnails/p/17203449.html)



![img](https://raw.gitcode.com/qq_36179938/images/raw/main/1680081-20230310151020667-1216144495.png)



![img](https://raw.gitcode.com/qq_36179938/images/raw/main/1680081-20230310151139056-962144899.png)



![img](https://raw.gitcode.com/qq_36179938/images/raw/main/1680081-20230310151251099-325190617.png)



![img](https://raw.gitcode.com/qq_36179938/images/raw/main/1680081-20230310151359013-1466259301.png)





### SqlSession的生命周期疑问

>每个线程都应该有自己的 SqlSession 实例。SqlSession 的实例不共享，并且不是线程安全的。因此，最佳作用域是请求或方法作用域。永远不要在静态字段甚至类的实例字段中保留对 SqlSession 实例的引用。永远不要在任何类型的托管作用域中保留对 SqlSession 的引用，例如 Servlet 框架的 HttpSession。如果您使用的是任何类型的 Web 框架，请考虑 SqlSession 遵循与 HTTP 请求类似的范围。换句话说，在收到 HTTP 请求时，您可以打开一个 SqlSession，然后在返回响应后，您可以关闭它。

在未实践时的理解类似于请求内单例, 比如线程Local中空-创建-返回的模式. 包括在查找的资料中也是一笔带过的. 但仔细想想其中有问题, 比如在事务中这样干似乎不合适. 浅写了代码得到的结果是从不同方式注入的SqlSession是一样的, 但这不代表上述理解完全错误, 在Spring下实际注入的类型是SqlSessionTemplate似乎仍旧保持了单例模式, 通过不同的拦截要求自动处理了SqlSession的创建和释放

```java
public class SqlSessionTemplate implements SqlSession, DisposableBean {

    public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory,
                              ExecutorType executorType, 
                              PersistenceExceptionTranslator exceptionTranslator) {

        this.sqlSessionFactory = sqlSessionFactory;
        this.executorType = executorType;
        this.exceptionTranslator = exceptionTranslator;
        
        // here
        this.sqlSessionProxy = (SqlSession)Proxy.newProxyInstance(SqlSessionFactory.class.getClassLoader(), new Class[]{SqlSession.class}, new SqlSessionInterceptor());
    }
}
```

