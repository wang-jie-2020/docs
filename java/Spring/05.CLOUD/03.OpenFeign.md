## 一、简单集成

### (1) 包 - @EnableFeignClients

​	核心包 spring-cloud-starter-openfeign 毫无疑问, 能够通过包含其他pom来增强(定义了一个文件包含可集成的Bean名, 如果能够在上下文中找到就可以进行增强), 常见的如:

​	spring-cloud-starter-loadbalancer

​	spring-cloud-starter-circuitbreaker-resilience4j (或 spring-cloud-starter-alibaba-sentinel)

上述的意思是, 比如断路器, 除了 feign.circuitbreaker.enabled=true, 还必需引入包circuitbreaker, 但只引包即可

okhttp、httpclient5 同样的模式

### (2) FeignClient

```java
public @interface FeignClient {
    
    // value和name的作用一样，如果没有配置url那么配置的值将作为服务名称，用于服务发现。反之只是一个名称。
    @AliasFor("name")
    String value() default "";	

    @AliasFor("value")
    String name() default "";
    
    // 相当于 name/value + contextId 需要唯一
    // 同一个name包含的是整个实例, 但其中可能存在不同模块，指定不同的contextId这样就不会冲突了。
    String contextId() default "";	

    // qualifier对应的是@Qualifier注解，使用场景跟上面的primary关系很淡，一般场景直接@Autowired直接注入就可以了。
    String qualifier() default "";

    // url用于配置指定服务的地址，相当于直接请求这个服务，不经过Ribbon的服务选择。像调试等场景可以使用。
    String url() default "";

    // 当调用请求发生404错误时，decode404的值为true，那么会执行decoder解码，否则抛出异常。
    boolean decode404() default false;

    // configuration是配置Feign配置类，在配置类中可以自定义Feign的Encoder、Decoder、LogLevel、Contract等。
    Class<?>[] configuration() default {};

    // 定义容错的处理类，也就是回退逻辑，fallback的类必须实现Feign Client的接口，无法知道熔断的异常信息。
    Class<?> fallback() default void.class;

    // 也是容错的处理，可以知道熔断的异常信息。
    Class<?> fallbackFactory() default void.class;

    String path() default "";
	
    //primary对应的是@Primary注解，默认为true，官方这样设置也是有原因的。
    //当我们的Feign实现了fallback后，也就意味着Feign Client有多个相同的Bean在Spring容器中，当我们在使用@Autowired进行注入的时候，不知道注入哪个，所以我们需要设置一个优先级高的，@Primary注解就是干这件事情的。
    boolean primary() default true;
}
```

结合mvc的api注解, 通过接口描述远端地址, 例子:

```java
@FeignClient(name = "samples", url = "http://127.0.0.1:10001", fallbackFactory = RemoteSampleFallbackFactory.class)
// @FeignClient(name = "samples", fallbackFactory = RemoteSampleFallbackFactory.class)
public interface RemoteSampleService {

    @RequestMapping(method = RequestMethod.GET, value = "/get")
    String get();

    @GetMapping("/anything/{anything}?page=1&size={size}")
    String getAnything(@PathVariable("anything") String name, @RequestParam("size") Long size);

    @PostMapping(value = "/anything")
    String postAnything(@RequestBody User user, @RequestHeader("X-Csrf-Token") String token);

    @PostMapping(value = "/status/500")
    String status500();
}
```

### (3) 拦截器 和 断路器

1. 拦截器, 通过RequestInterceptor接口实现注册Bean即可(@Component 或 RequestInterceptor Bean二选一的意思), 单向拦截

```java
@Bean
public RequestInterceptor requestInterceptor() {
    return new FeignRequestInterceptor();
}
```

```java
@Component
public class FeignRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        Map<String, String> headers = new LinkedCaseInsensitiveMap<>();

        Enumeration<String> enumeration = request.getHeaderNames();
        if (enumeration != null)
        {
            while (enumeration.hasMoreElements())
            {
                String key = enumeration.nextElement();
                String value = request.getHeader(key);
                headers.put(key, value);
            }
        }

        requestTemplate.header("Authorization", "Bearer xyz");
        requestTemplate.header("X-Forwarded-For", "127.0.0.1");
    }
}
```



2. 断路器, 通过FallbackFactory接口实现注册Bean即可

```java
@Component
public class RemoteSampleFallbackFactory implements FallbackFactory<RemoteSampleService>
{
    private static final Logger log = LoggerFactory.getLogger(RemoteSampleService.class);

    @Override
    public RemoteSampleService create(Throwable throwable)
    {
        return new RemoteSampleService()
        {
            @Override
            public String status500()
            {
                return ("服务调用失败");
            }
        };
    }
}
```



## 二、一些实际问题

### (1) 理解思路

​	Feign是一个声明式Web服务客户端, 通过注解的方式描述如何进行web请求. 它为每个指定客户端创建了一个上下文(此处有疑问), 通过全局配置和客户端配置,

结合Spring Web中的默认(比如编码器、解码器, HttpMessageConverters等等)实现远程过程调用. 提供拦截和回退(spring circuitbreaker), 提供负载

均衡(spring loadbalancer). Feign客户端 可以由注解创建或者Builder创建, 每一个客户端都可以实现完全控制.

​	默认提供了Decoder、Encoder、Logger、Contract、Client等等Bean对象, 也有Metrics相关Bean(未了解)

### (2) 全局配置 和 个性配置

配置项有这些: 

![在这里插入图片描述](https://raw.gitcode.com/qq_36179938/images/raw/main/2e2f8b1d1e1d16b463044cea9a537e6f.png)



![在这里插入图片描述](https://raw.gitcode.com/qq_36179938/images/raw/main/2a3d98e6d3f59365fdaed38a4be17497.png)

当然可以通过配置文件或者Bean的模式进行全局修改, 比如:

![image-20251216134726173](https://raw.gitcode.com/qq_36179938/images/raw/main/image-20251216134726173.png)



个性配置的方式包括 @FeignClient 附加配置 或者 配置文件中的拓展, 后者通过默认的结构实现对每一个客户端的配置, 比如

​	feign.client.config.feignName: xxx 下即可对Name是xxx的客户端进行配置(spring.cloud.openfeign 点不出来??)

@FeignClient 附加配置的形式如:

```java
@FeignClient(name = "user2", url = "http://127.0.0.1:9201", configuration = RemoteUserFeignConfig.class)
```

注意: 不需要 @Configuration 或者 @Component 进行注释, 否则会将其作为默认全局. 需要@Bean注解来描述配置项修改.

### (3) Decode的问题

在默认情况会以SpringDecoder、HttpMessageConverters进行json解码, 这其中会出现一个项目间的差别, 比如日期格式的Format问题

```java
    @Bean
    public feign.codec.Decoder userServiceDecoder() {
        ObjectMapper objectMapper = new ObjectMapper();

        SimpleModule module = new SimpleModule();
        module.addDeserializer(Date.class, new MultiFormatDateDeserializer());
        module.addDeserializer(LocalDateTime.class, new MultiFormatLocalDateTimeDeserializer());
        objectMapper.registerModule(module);

        return new ResponseEntityDecoder(
                new SpringDecoder(() -> new HttpMessageConverters(
                        new MappingJackson2HttpMessageConverter(objectMapper)
                ))
        );
    }
```




































