## 一、Route

路由包含 ID、目标 URI、谓词集合和过滤器集合。谓词可以理解成匹配HTTP请求任何内容的名词。路由示例比如: 

```yml
- id: xxx
  uri: xxx
  predicates:
    - Path=/system/**
  filters:
    - StripPrefix=1
```

请求URL中满足PATH匹配条件的，经过StripPrefix过滤（1指的是网页分段index，比如/system/user即请求uri/user）

### (1) Route Predicate

built-in route predicate factories:

```yml
Datetime - After=2021-02-23T14:20:00.000+08:00[Asia/Shanghai]   Before、Between
Cookie   - Cookie=loginname, ruoyi
Header   - Header=X-Request-Id, \d+
Host     - Host=**.somehost.org,**.anotherhost.org
Method   - Method=GET,POST
Path     - Path=/system/**
Query    - Query=username, abc.
RemoteAddr  - RemoteAddr=192.168.10.1/0
Weight  - Weight=group1, 2
XForwardedRemoteAddr=192.168.1.1/24
```

Custom-Prrdicate: [AbstractRoutePredicateFactory](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#developer-guide)



### (2) Route Filter

built-in route filter factories:

```yml
# GatewayFilter
CircuitBreaker		- todo
CacheRequestBody    - todo
RequestRateLimiter  - todo
StripPrefix			- StripPrefix 有些类似于Nginx的Location, SetPath 和它有些类似
```



范围上全局过滤器、特定过滤器, 函数签名类似, AbstractGatewayFilterFactory vs GlobalFilter

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#writing-custom-gatewayfilter-factories

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#writing-custom-global-filters



在Pre、Post两个阶段进行过滤如下:

```java
@Override
public GatewayFilter apply(Config config) {
    return (exchange, chain) -> {
        // custom pre-processing

        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            // custom post-processing
        }));
    };
}
```



### (3) Custom-Route

(1) `RouteLocator` + `RouteDefinitionLocator` 进行路由自定义, 如果已经有配置中心集成此处意义不大

(2) `RouterFunction` 不是Gateway包下的, 效果能够理解但其api还是不熟悉的



### (4) ExceptionHandler

实现`ErrorWebExceptionHandler`进行全局处理, 但注意这只是网关异常处理, 服务异常仍旧需要自行处理



## 二、实践问题

### (1) 有些包装需要了解

​	ServerWebExchange

​		DataBuffer dataBuffer = response.bufferFactory().wrap(JSON.toJSONString(result).getBytes());

​		exchange.getResponse().writeWith(Mono.just(dataBuffer));



​		exchange.getRequest().getURI().getPath()

​		ServerHttpRequest request = exchange.getRequest();

​		ServerHttpRequest.Builder mutate = request.mutate();

​	reactor.core.publisher.Mono

​		Mono.error(ex)

### (2) Request 、Response 的修改

​	Response 似乎关系不大, exchange.getResponse() 可以直接进行

​	Request 的读(Body)和写有限制

​		ServerHttpRequest request = exchange.getRequest();	// header可读, 不写

​		ServerHttpRequest.Builder mutate = request.mutate();  // 这样

​		return chain.filter(exchange.mutate().request(mutate.build()).build());



​		CacheRequestBody

​		

​		xss中进行了Body的修改, 代码不贴了



### (3) 熔断降级 CircuitBreaker

`spring-cloud-starter-circuitbreaker-reactor-resilience4j`



### (4) 限流 RequestRateLimiter

限流算法:
**计数器: 每个单位时间能通过的请求数固定，超过阈值直接拒绝。**

通过维护一个单位时间内的计数器，每次请求计数器加1，当单位时间内计数器累加到大于设定的阈值，则之后的请求都被绝，直到单位时间已经过去，再将计数器重置为零。

**漏桶算法: 维持一个队列，所有请求先进队列，然后从队列取出请求的速率是固定。【保护请求】**

漏桶算法可以很好地限制容量池的大小，从而防止流量暴增。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。

漏桶算法需要通过两个变量进行控制：一个是桶的大小，支持流量突发增多时可以存多少的水（burst），另一个是水桶漏洞的大小（rate）（从队列取出请求）

**令牌桶算法: 按一定额定的速率产生令牌，存入令牌桶，桶有最大容量（应该为微服务最大承载）；服务过来时需要请求到一个令牌才可以进入服务执行；服务里就可以保持基本不会超过承载值。【保护服务】**

令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。



具体实现逻辑在RequestRateLimiterGatewayFilterFactory类中, lua脚本 ![img](https://img-blog.csdnimg.cn/img_convert/e2e8184e3b6ac5091722414e44fd7fee.png)



### (5) Sentinel 流控和降级

Sentinel