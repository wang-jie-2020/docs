# Gateway

## 路由谓词和过滤

路由包含 ID、目标 URI、谓词集合和过滤器集合。谓词可以理解成匹配HTTP请求任何内容的名词。

### 谓词

结合谓词和过滤器进行转发与否的判断，在微服务中最常见的一种配置是由Nacos服务进行统一发现转发：

```yml
- id: xxx
  uri: xxx
  predicates:
    - Path=/system/**
  filters:
    - StripPrefix=1
```

上述的意思是: 请求URL中满足PATH匹配条件的，经过StripPrefix过滤（1指的是网页分段index，比如/system/user即请求user-controller）转发到目标uri

预构建谓词中有非常多，似乎不太需要关注（自定义 可集成AbstractRoutePredicateFactory）

### 过滤器

过滤器包含了过滤器工厂、全局过滤器两个实现，两者的函数签名、逻辑都相似，区别在于字面意义上的特定存在、全局

1. 过滤器工厂继承自`AbstractGatewayFilterFactory`, 在Config上稍微堵了一会注意构造函数。当然不是唯一写法，自己写配置类再注入也行（注意要考虑运行刷新）

```java
@Component
public class BlackListFilter extends AbstractGatewayFilterFactory<BlackListFilter.Config> {

    /// 注意:不能少, 否则会传递Object到bind()绑定不了
    public BlackListFilter() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(BlackListFilter.Config config) {

        return (exchange, chain) -> {

            String url = exchange.getRequest().getURI().getPath();
            if (config.matchBlacklist(url))
            {
                ServerHttpResponse response = exchange.getResponse();

                response.setStatusCode(HttpStatus.OK);
                response.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);

                R<?> result = R.fail(R.fail(), "请求地址不允许访问");
                DataBuffer dataBuffer = response.bufferFactory().wrap(JSON.toJSONString(result).getBytes());
                return response.writeWith(Mono.just(dataBuffer));
            }

            return chain.filter(exchange);
        };
    }

    /// config 会从配置中的args带过来
    public static class Config {
        private List<String> blacklistUrl;

        private List<Pattern> blacklistUrlPattern = new ArrayList<>();

        public boolean matchBlacklist(String url)
        {
            return !blacklistUrlPattern.isEmpty() && blacklistUrlPattern.stream().anyMatch(p -> p.matcher(url).find());
        }

        public List<String> getBlacklistUrl()
        {
            return blacklistUrl;
        }

        public void setBlacklistUrl(List<String> blacklistUrl)
        {
            this.blacklistUrl = blacklistUrl;
            this.blacklistUrlPattern.clear();
            this.blacklistUrl.forEach(url -> {
                this.blacklistUrlPattern.add(Pattern.compile(url.replaceAll("\\*\\*", "(.*?)"), Pattern.CASE_INSENSITIVE));
            });
        }
    }
}
```

```yml
        - id: project-system
          uri: lb://project-system
          predicates:
            - Path=/system/**
          filters:
            - StripPrefix=1
            - name: BlackListFilter
              args:
                blacklistUrl:
                  - /user/password/*
                  - /user/profile/*
```





AbstractGatewayFilterFactory vs GlobalFilter

CacheRequestBody



熔断降级

​	FALLBACK







限流算法
计数器

每个单位时间能通过的请求数固定，超过阈值直接拒绝。

通过维护一个单位时间内的计数器，每次请求计数器加1，当单位时间内计数器累加到大于设定的阈值，则之后的请求都被绝，直到单位时间已经过去，再将计数器重置为零。

漏桶算法

维持一个队列，所有请求先进队列，然后从队列取出请求的速率是固定。【保护请求】

漏桶算法可以很好地限制容量池的大小，从而防止流量暴增。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。

漏桶算法需要通过两个变量进行控制：一个是桶的大小，支持流量突发增多时可以存多少的水（burst），另一个是水桶漏洞的大小（rate）（从队列取出请求）

令牌桶算法

按一定额定的速率产生令牌，存入令牌桶，桶有最大容量（应该为微服务最大承载）；服务过来时需要请求到一个令牌才可以进入服务执行；服务里就可以保持基本不会超过承载值。【保护服务】

令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。



具体实现逻辑在RequestRateLimiterGatewayFilterFactory类中, lua脚本 ![img](https://img-blog.csdnimg.cn/img_convert/e2e8184e3b6ac5091722414e44fd7fee.png)

```yaml
        filters:
        - name: RequestRateLimiter
          args:
            key-resolver: '#{@userKeyResolver}'
            redis-rate-limiter.replenishRate: 1
            redis-rate-limiter.burstCapacity: 3
```

```java
@Bean

KeyResolver userKeyResolver() {
  return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst("user"));
    return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getHostName());
    return exchange -> Mono.just(exchange.getRequest().getPath().value());
    
}

```



整合一波swagger?

## Sentinel完成流控和降级

```java
网关限流参数
其中网关限流规则 GatewayFlowRule的字段解释如下：

resource：资源名称，可以是网关中的 route 名称或者用户自定义的 API 分组名称。

resourceMode：规则是针对 API Gateway 的 route（RESOURCE_MODE_ROUTE_ID）还是用户在 Sentinel 中定义的 API 分组（RESOURCE_MODE_CUSTOM_API_NAME），默认是 route。

grade：限流指标维度，同限流规则的 grade 字段。

count：限流阈值

intervalSec：统计时间窗口，单位是秒，默认是 1 秒。

controlBehavior：流量整形的控制效果，同限流规则的 controlBehavior 字段，目前支持快速失败和匀速排队两种模式，默认是快速失败。

burst：应对突发请求时额外允许的请求数目。

maxQueueingTimeoutMs：匀速排队模式下的最长排队时间，单位是毫秒，仅在匀速排队模式下生效。

paramItem

参数限流配置。若不提供，则代表不针对参数进行限流，该网关规则将会被转换成普通流控规则；否则会转换成热点规则。其中的字段：

parseStrategy：从请求中提取参数的策略，目前支持提取来源 IP（PARAM_PARSE_STRATEGY_CLIENT_IP）、Host（PARAM_PARSE_STRATEGY_HOST）、任意 Header（PARAM_PARSE_STRATEGY_HEADER）和任意 URL 参数（PARAM_PARSE_STRATEGY_URL_PARAM）四种模式。
fieldName：若提取策略选择 Header 模式或 URL 参数模式，则需要指定对应的 header 名称或 URL 参数名称。
pattern：参数值的匹配模式，只有匹配该模式的请求属性值会纳入统计和流控；若为空则统计该请求属性的所有值。（1.6.2 版本开始支持）
matchStrategy：参数值的匹配策略，目前支持精确匹配（PARAM_MATCH_STRATEGY_EXACT）、子串匹配（PARAM_MATCH_STRATEGY_CONTAINS）和正则匹配（PARAM_MATCH_STRATEGY_REGEX）。（1.6.2 版本开始支持）
用户可以通过 GatewayRuleManager.loadRules(rules) 手动加载网关规则，或通过 GatewayRuleManager.register2Property(property) 注册动态规则源动态推送（推荐方式）。
```

