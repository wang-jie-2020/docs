*也许以线程池xxx之类更符合意思? JAVA的TAP模式会相对好理解*



## 概述

TAP的第一层大概还是(1) 线程池概念和配置方式 (2) 注解和注解场景



### 线程池概念和配置

1. 不要混淆ThreadPoolTaskExecutor (Spring) 和 ThreadPoolExecutor (jdk), 前者是框架默认实现

2. 在默认下, 相关对象是 SimpleAsyncTaskExecutor、ThreadPoolTaskExecutor,由于默认配置有问题约等于项目必须配置

   配置文件方式 或 java代码(推荐实现AsyncConfigurer,非必要)

```yml
spring:
  task:
    execution:
      thread-name-prefix: xxx
      pool:
        max-size: 6
        core-size: 3
        keep-alive: 30s
        queue-capacity: 500

```

```java
// ThreadPoolTaskExecutor 在org.springframework.scheduling.concurrent 包下
@Bean(name = "threadPoolTaskExecutor")
public ThreadPoolTaskExecutor threadPoolTaskExecutor()
{
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setMaxPoolSize(maxPoolSize);
    executor.setCorePoolSize(corePoolSize);
    executor.setQueueCapacity(queueCapacity);
    executor.setKeepAliveSeconds(keepAliveSeconds);
    // 线程池对拒绝任务(无线程可用)的处理策略
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
    return executor;
}

// ScheduledExecutorService 在java.util.concurrent 包下
@Bean(name = "scheduledExecutorService")
protected ScheduledExecutorService scheduledExecutorService()
{
    return new ScheduledThreadPoolExecutor(corePoolSize,
            new BasicThreadFactory.Builder().namingPattern("schedule-pool-%d").daemon(true).build(),
            new ThreadPoolExecutor.CallerRunsPolicy())
    {
        @Override
        protected void afterExecute(Runnable r, Throwable t)
        {
            super.afterExecute(r, t);
            Threads.printException(r, t);
        }
    };
}
```



而在jdk中大概会是这样的:

```java
ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);
ScheduledFuture<?> future = executor.schedule();
ScheduledFuture<?> future = executor.scheduleAtFixedRate();
ScheduledFuture<?> future = executor.scheduleWithFixedDelay();

ExecutorService executor = Executors.newFixedThreadPool(1);
Future<Integer> future = executor.submit(task);
```



### 注解和注解场景

@EnableAsync、@Async、@Async("具名线程调度器")

遵循aop的相关场景, 该失效的地方还是一样的...



RuoYi的AsyncManager未直接以注解方式解决:

```java
public class AsyncManager {
    
    private ScheduledExecutorService executor = SpringUtils.getBean("scheduledExecutorService");
    
    private AsyncManager() {
    }
    
    private static AsyncManager me = new AsyncManager();

    public static AsyncManager me() {
        return me;
    }
    
    public void execute(TimerTask task) {
        executor.schedule(task, OPERATE_DELAY_TIME, TimeUnit.MILLISECONDS);
    }
}
```

