*也许以线程池xxx之类更符合意思? JAVA的TAP模式会相对好理解*



## 概述

TAP的第一层大概还是(1) 线程池概念和配置方式 (2) 注解和注解场景, 其他资料当作了解吧.



默认线程池为SimpleAsyncTaskExecutor, 一个任务一个线程之类, 不必看了, 约等于项目必重新配置.

配置文件(略) 或 java代码(推荐实现AsyncConfigurer,非必要)

```yml
spring:
  task:
    execution:
      thread-name-prefix: xxx
      pool:
        max-size: 6
        core-size: 3
        keep-alive: 30s
        queue-capacity: 500

```

```java
@Bean(name = "threadPoolTaskExecutor")
public ThreadPoolTaskExecutor threadPoolTaskExecutor()
{
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setMaxPoolSize(maxPoolSize);
    executor.setCorePoolSize(corePoolSize);
    executor.setQueueCapacity(queueCapacity);
    executor.setKeepAliveSeconds(keepAliveSeconds);
    // 线程池对拒绝任务(无线程可用)的处理策略
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
    return executor;
}

@Bean(name = "scheduledExecutorService")
protected ScheduledExecutorService scheduledExecutorService()
{
    return new ScheduledThreadPoolExecutor(corePoolSize,
            new BasicThreadFactory.Builder().namingPattern("schedule-pool-%d").daemon(true).build(),
            new ThreadPoolExecutor.CallerRunsPolicy())
    {
        @Override
        protected void afterExecute(Runnable r, Throwable t)
        {
            super.afterExecute(r, t);
            Threads.printException(r, t);
        }
    };
}
```



注解@EnableAsync、@Async、@Async("具名线程调度器") 遵循aop的相关场景, 该失效的地方还是一样的...



## 例子

### RuoYi的AsyncManager(而非Async)

```java
public class AsyncManager {
    
    private ScheduledExecutorService executor = SpringUtils.getBean("scheduledExecutorService");
    
    private AsyncManager() {
    }
    
    private static AsyncManager me = new AsyncManager();

    public static AsyncManager me() {
        return me;
    }
    
    public void execute(TimerTask task) {
        executor.schedule(task, OPERATE_DELAY_TIME, TimeUnit.MILLISECONDS);
    }
}
```

