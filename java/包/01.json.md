# JSON

## Jackson

```xml
<!-- **jackson-databind** 包含了 **jackson-annotations** **jackson-core** -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

### 注解

- 控制输出:

  @JsonProperty	

​	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")  小坑见下一节

​	@JsonSerialize(using = ToStringSerializer.class)

​	@JacksonAnnotationsInside  内联标记

- 控制忽略:

​	@JsonIgnore  @JsonIgnoreProperties  @JsonIgnoreType

​	@JsonManagedReference @JsonBackReference

### 时间类型问题

- 在SpringBoot中默认集成了jsr310包支持java8特性(如LocalDateTime类型支持), 如果在其他场景下需要手动注册模块

- 时间格式化, 可以通过JsonFormat单个注解, 或者通过全局配置

  builder.simpleDateFormat("yyyy-MM-dd HH:mm:ss");

  spring.jackson.date-format = yyyy-MM-dd HH:mm:ss

  全局配置影响Date, LocalDateTime额外配置

  ```java
  builder.serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
  builder.deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
  ```

### 配置重写

1. 定制 Jackson2ObjectMapperBuilderCustomizer Bean
2. 定制 MappingJackson2HttpMessageConverter Bean

```java
@Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -> {
            builder.simpleDateFormat("yyyy-MM-dd HH:mm:ss");
            builder.serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            builder.deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));

//            SimpleModule module = new SimpleModule();
//            module.addSerializer(Long.class, new LongSerializer());
//            module.addSerializer(long.class, new LongSerializer());
//            builder.modules(module);

            builder.serializerByType(long.class, new LongSerializer());
            builder.serializerByType(Long.class, new LongSerializer());

            builder.featuresToDisable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);  // 禁用时区自动调整
        };
    }

```

```java
    @Bean
    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {

        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();

        ObjectMapper objectMapper = new ObjectMapper();

        .....

        converter.setObjectMapper(objectMapper);

        return converter;
    }
```

### 自定义注解标记:自定义注解控制输出(Sensitive敏感信息脱离)

@JacksonAnnotationsInside  内联标记 --> 标记了@Sensitive 就像直接在那个元素上使用了 @JsonSerialize

@JsonSerialize

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@JacksonAnnotationsInside
@JsonSerialize(using = SensitiveJsonSerializer.class)
public @interface Sensitive
{
    // 枚举
    DesensitizedType desensitizedType();
}
```

```java
/**
 * 数据脱敏序列化过滤
 *   有个细节: 已经在需要特殊处理的字段上标注了@JsonSerialize(using = SensitiveJsonSerializer.class),为什么还需要ContextualSerializer?
 *      尝试注释掉接口,一样可以断到..问题在于无法拿到注解
 *
 */
public class SensitiveJsonSerializer extends JsonSerializer<String> implements ContextualSerializer
{
    private DesensitizedType desensitizedType;

    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException
    {
        // s -> func(s)
        gen.writeString(desensitizedType.desensitizer().apply(value));
    }

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)
            throws JsonMappingException
    {
        Sensitive annotation = property.getAnnotation(Sensitive.class);
        if (Objects.nonNull(annotation) && Objects.equals(String.class, property.getType().getRawClass()))
        {
            this.desensitizedType = annotation.desensitizedType();
            return this;
        }
        return prov.findValueSerializer(property.getType(), property);
    }
}
```



## FastJson2

```xml
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
</dependency>
```

JSON.toJSONString()

JSON.parse()



其他常见注解:

​	控制输出:

​		@JSONField(name=”resType”) 

​		@JSONField(format=”yyyy-MM-dd”) 

​	控制忽略:

​		@JSONField(serialize = false)

​	定制:

​		toJSONString(Object object, Filter filter, JSONWriter.Feature... features) 函数签名中可以传递Filter

​		比如SimplePropertyPreFilter，允许通过指定属性名来过滤字段。

​		参见 com.ruoyi.common.filter.PropertyPreExcludeFilter



## TAG

*在Fastjson的早期版本中是会被Jasckson的注解影响的 https://github.com/alibaba/fastjson2/issues/716*

```
JSONFactory.setUseJacksonAnnotation(false);
```