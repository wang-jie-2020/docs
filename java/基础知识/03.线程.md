# 多线程

## 基础

可见性、原子性、有序性

Thread Runnable Callable

Exector



## 线程和执行器

通过Thread指定一个新的线程:

- extends Thread 
- implements Runnable
- implements Callable

通过匿名或者Lambda表达式指定Thread任务:

```csharp
new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("runnable method");
    }
}).start();
```



通过Executos指定线程池复用线程:

- 方法签名

  ```java
  public interface Executor {
      void execute(Runnable command);
  }
  ```

  ```java
  public interface ExecutorService extends Executor {
      <T> Future<T> submit(Callable<T> task);
  
      <T> Future<T> submit(Runnable task, T result);
  
      Future<?> submit(Runnable task);
  
      <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
          throws InterruptedException;
  
      <T> T invokeAny(Collection<? extends Callable<T>> tasks)
          throws InterruptedException, ExecutionException;
  
      <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                      long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException;
  }
  ```

- Callable和Future

  Future类似于C#中的AsyncState或者Task,Future.get()将会产生阻塞

- executor

  Executors必须显式的停止-否则它们将持续监听新的任务

  ```java
  try {
      executor.shutdown();
      executor.awaitTermination(5, TimeUnit.SECONDS);
  } catch (InterruptedException e) {
      
  } finally {
      if (!executor.isTerminated()) {
          
      }
      executor.shutdownNow();
  }
  ```

```java
ExecutorService executor = Executors.newFixedThreadPool(1);
    
//Future<?> submit(Runnable task);
executor.submit(() -> {

});

//<T> Future<T> submit(Callable<T> task);
Future<Integer> future = executor.submit(() -> {
    return 1;
});

//<T> Future<T> submit(Runnable task, T result);
Future<Integer> future2 = executor.submit(() -> {
},1);

futrue.get()
executor.shutdown();
```



### FutureTask

![img](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/java-thread-x-juc-futuretask-1.png)

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```





## 线程同步

juc ... java.utils.concurrnet 

**synchronized** 关键字,修饰方法或代码块,但注意实际的lock对象是this

**ReentrantLock** 互斥锁

**ReadWriteLock** 读写锁

Wait、Notify	Object方法，类似于ManualResetEvent，信号模式



原子操作和集合包装

**AtomicInteger**

**Collections.sychronizedList()**









| 比较项目       | wait             | await            | sleep          | yield        | join             |
| -------------- | ---------------- | ---------------- | -------------- | ------------ | ---------------- |
| 是否释放持有锁 | 释放             | 释放             | 不释放         | 不释放       | t1不释放         |
| 谁的方法       | Object           | Condition        | Thread         | Thread       | 线程对象         |
| 唤醒方法       | nogify/nogifyAll | signal/signalAll | 指定时间后     | 自动唤醒     | t2执行完自动唤醒 |
| 何时就绪       | 唤醒后就绪       | 唤醒后就绪       | 指定时间后就绪 | 立刻进入就绪 | t2完成后进入就绪 |
| 执行环境       | 同步代码块       | 同步代码快       | 任意位置       | 任意位置     | 任意位置         |