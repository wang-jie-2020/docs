*简单概括下逆变和协变解决的问题： List<子类> 不能传递给 List<基类>，这有些反直觉（一只狗是一只动物，一群狗不是一群动物）*

解决的是类型兼容问题：

​	Get(List<Animal> animals) --- 只能传递<基类>

​	Get(List<T> animals) where T: Animal --- <基类> 或 <子类>



由于已经进行了封装，编码过程中不常见in、out关键字，比如：

```csharp
interface IEnumerable<out T> : IEnumerable
```

```csharp
delegate void Action<in T>(T obj);
delegate TResult Func<out TResult>();
```



in = 消费类型，消费类型中的共同特征

```csharp
Action<Animal> animalAction = (_) => { Console.WriteLine("animal"); };
Action<Dog> dogAction = (_) => { Console.WriteLine("dog"); };

//animalAction = dogAction;   //语法错误
dogAction = animalAction;

dogAction(new Dog());   // animal
```



out = 生产类型，符合直觉

```csharp
Func<Animal> animalFunction = () => { Console.WriteLine("animal");  return null; };
Func<Dog> dogFunction = () => { Console.WriteLine("dog"); return null; };

animalFunction = dogFunction;
//dogFunction = animalFunction; // 语法错误

animalFunction();   // dog
```

