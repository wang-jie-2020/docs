# 雪花

> 结构如下(每部分用-分开)
>
> 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000
>
> 1位标识
>
> ​	最高位是符号位是0
>
> 
>
> 41位时间截(毫秒级)
>
> ​	时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)得到的值）
>
> ​	41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69
>
> 
>
> 10位的数据机器位
>
> ​	1024个节点
>
> 
>
> 12位序列
>
> ​	毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号



实现算法描述:

时间戳	<< 	22	|

机器码	<<	 12	|

序列码



00000000-00000000-00000000-00000000-00000000-00000000-00000000-00000000



00000000-00000000-00000001-11111111-11111111-11111111-11111111-11111111	<< 22

01111111-11111111-11111111-11111111-11111111-11000000-00000000-00000000



00000000-00000000-00000000-00000000-00000000-00000000-00000011-11111111	<< 12

00000000-00000000-00000000-00000000-00000000-00111111-11110000-00000000	



00000000-00000000-00000000-00000000-00000000-00000000-00001111-11111111



> IEEE 754 双精度浮点数使用 64 位来表示 3 个部分：
>
> + 1 比特*符号位*（sign）（正数或者负数）
> + 11 比特*指数位*（exponent）（-1022 到 1023）
> + 52 比特*尾数位*（mantissa）（表示 0 和 1 之间的数值）

这意味着在表示整数时,NUMBER类型最大提供54个bit,与LONG类型的64bit相比存在精度损失



*0 + 41**位时间戳* *+ 10**位机器码* *+ 12**位序列码*	--->

*0 + 40**位时间戳* *+ 2**位机器码*  *+ 11**位序列码*

时间戳68年-->时间戳34年

机器码1024-->机器码4

序列数4096-->序列数2048



时间戳	<< 	13	|

机器码	<<	 11	|

序列码



Nuget：https://github.com/yitter/IdGenerator

