## 一、语言基础

### 1.1 数据

1. 整数、浮点数、字符串、布尔、空值

2. 字符格式化

   1. `r''`表示`''`内部的字符串默认不转义

   2. `'''...'''`的格式表示多行内容

   3. 格式化

      (1)%  (2)format  (3)f-string

      ```python
      # %s %d %f 
      'Age: %s. Gender: %s' % (25, True)
      
      # .format
      'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
      
      # f'{}'中的替换
      r = 2.5
      s = 3.14 * r ** 2
      print(f'The area of a circle with radius {r} is {s:.2f}')
      ```

### 1.2 条件、循环

#### 条件

1. if-elif-else

2. match-case

   case _: 	# _表示匹配到其他任何情况

   高级一些的玩法包括

   ​	合并模式 --- case 200|201: description = 'Success'

   ​	匹配模式(不太确定名字), 如下

```python
args = ['gcc', 'hello.c', 'world.c']
# args = ['clean']
# args = ['gcc']

match args:
    # 如果仅出现gcc，报错:
    case ['gcc']:
        print('gcc: missing source file(s).')
    # 出现gcc，且至少指定了一个文件:
    case ['gcc', file1, *files]:
        print('gcc compile: ' + file1 + ', ' + ', '.join(files))
    # 仅出现clean:
    case ['clean']:
        print('clean')
    case _:
        print('invalid command.')
```

#### 循环

1. for-in

   for name in names

​	for row, name in enumerate(names)

2. while-break-continue



## 二、常用数据结构

| 特性             | 列表 (List)                       | 元组 (Tuple)                      | 集合 (Set)                             | 字典 (Dictionary)                  |
| ---------------- | --------------------------------- | --------------------------------- | -------------------------------------- | ---------------------------------- |
| **可变性**       | 可变                              | 不可变                            | 可变                                   | 可变                               |
| **元素类型**     | 任意类型（可包含可变/不可变对象） | 任意类型（可包含可变/不可变对象） | 必须为不可变对象（可哈希）             | 键必须为不可变对象，值可为任意类型 |
| **有序性**       | 有序                              | 有序                              | 无序                                   | 有序（Python 3.7+）                |
| **允许重复元素** | 是                                | 是                                | 否                                     | 键唯一，值可重复                   |
| **语法示例**     | `[1, 'a', [2]]`                   | `(1, 'a', [2])`                   | `{1, 2, 3}`                            | `{'key1': 10, 'key2': 20}`         |
| **适用场景**     | 动态数据集合，需频繁增删改查      | 固定数据集合（如配置项、常量）    | 去重、快速成员检查、集合运算（交并差） | 键值对映射，快速通过键查找值       |
| **是否支持索引** | 是（`list[0]`）                   | 是（`tuple[0]`）                  | 否                                     | 通过键访问（`dict['key']`）        |
| **内存占用**     | 较高（因预留空间）                | 较低（不可变，存储紧凑）          | 高（哈希表实现）                       | 高（哈希表实现）                   |
| **底层实现**     | 动态数组                          | 静态数组                          | 哈希表                                 | 哈希表                             |

### 2.1 切片

形如`[start:end:stride]`的运算符，其中`start`代表访问列表元素的起始位置，`end`代表访问列表元素的终止位置（终止位置的元素无法访问），而`stride`则代表了跨度，简单的说就是位置的增量。

### 2.2 常见操作方法

1. `+` 和 `*`
2. `in`

3. `append`、`insert`、`remove`、`pop`、`index`

4. `dict.get`

### 2.3 补充-dict的键

在Python中，只有不可变类型的对象才是可哈希的，例如整数、浮点数、字符串和元组。自定义类默认是不可哈希的，因为它们通常是可变的。

~~但是可以进行一些操作如定义不可变属性，`hash` 和 `eq`方法（估计很少，不再深究）~~



## 三、函数

### 1.1 参数顺序

参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

`*args`是可变参数，args接收的是一个tuple；

`**kw`是关键字参数，kw接收的是一个dict。

默认参数中需注意指向不可变对象, add_end(L=[]) 在不传实参时有指向问题

### 1.2 装饰器

@decorator 等价于 func = decorator(func)，参照Aop理解

函数签名 wrapper(*args,**kw), 一个例子：

```python
def log(text):	# text是装饰器参数
    def decorator(func):
        @functools.wraps(func)	# 解决name问题
        def wrapper(*args, **kw):
            return func(*args, **kw)

        return wrapper

    return decorator
```

常见装饰器: @property、@dataclass

### 1.3 偏函数

偏函数（Partial function）有点类似于静态扩展方法

简单总结`functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

```python
int2 = functools.partial(int, base=2)
int8 = functools.partial(int, base=8)
print(int2('1001'))   # 9
print(int8('1001'))   # 513
```

### 1.4 Lambda函数

关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数。

map(f, [x1, x2, x3, x4]) = f(x1),f(x2),f(x3),f(x4)

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map/reduce/filter	类比lambda.select/aggregate/where



## 四、面向对象

### 动态特性、继承多态

实例并不像静态语言那样'继承'类属性，比如在静态语言中类必须实例化才有对象的概念，非静态的成员是无法被直接访问的，但在python中更像一种拷贝

*个人理解：继承实际上就是绑定了一个当前实例的dict -> 类的dict,,,如果实例新增或重写属性那么就新增实例的dict中的属性，否则就直接链向类的dict*



允许多重继承, DAG排序, https://www.jianshu.com/p/c9a0b055947b

### 静态方法和类方法

```python
@staticmethod
def is_valid(a, b, c):
	"""判断三条边长能否构成三角形(静态方法)"""
	return a + b > c and b + c > a and a + c > b

# 或者

 @classmethod
 def is_valid(cls, a, b, c):
     ""判断三条边长能否构成三角形(类方法)"""
     return a + b > c and b + c > a and a + c > b

```

### 预定义方法

`__init__`、`__slots__`

`__repr__` `__str__`



## 五、进程、线程

https://www.cnblogs.com/midworld/p/14614640.html

https://www.cnblogs.com/midworld/p/14614634.html

### multiprocessing.Process

multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)



multiprocessing.Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)

​	apply(func, args=(), kwds={}, callback=None, error_callback=None) 

​	apply_async(func, args=(), kwds={}, callback=None, error_callback=None)

​	map(func, iterable, chunksize=None)

​	map_async(func, iterable, chunksize=None, callback=None, error_callback=None)



#### 进程间通信

每个进程是相互独立的，内存无法共享，实现进程间数据共享的方式有：

- multiprocessing.Value(typecode_or_type, *args, lock=True)：共享单个数据，共享内存
- multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)：共享数组，共享内存
- multiprocessing.Manager(`：共享进程，支持多种数据结构的数据共享

Manager 支持的类型有：list,dict,Namespace,Lock,RLock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Value和Array，**不仅可以在本地进程间共享，甚至可以在多客户端实现网络共享**，不过 Manager占用资源较大。

### concurrent.futures 模块

```PYTHON
    with concurrent.futures.ProcessPoolExecutor() as executor:
        executor.submit(run_proc, "main")
        executor.map(run_proc, "main")

    with concurrent.futures.ThreadPoolExecutor() as executor:
        executor.submit(run_proc, "main")
        executor.map(run_proc, "main")
```

`Future` 类封装了可调用对象的异步执行，由 `Executor.submit()` 产生, 可以操作处理状态以及增加回调、处理错误等；