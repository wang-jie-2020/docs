## 字符格式化

1. `r''`表示`''`内部的字符串默认不转义

2. `'''...'''`的格式表示多行内容

3. 格式化:

   (1)%  (2)format  (3)f-string

```python
# %s %d %f 
'Age: %s. Gender: %s' % (25, True)

# .format
'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)

# f'{}'中的替换
r = 2.5
s = 3.14 * r ** 2
print(f'The area of a circle with radius {r} is {s:.2f}')
```



## 控制逻辑

### 条件语句

1. if-elif-else

2. match-case

   case _: 	# _表示匹配到其他任何情况

```python
args = ['gcc', 'hello.c', 'world.c']
# args = ['clean']
# args = ['gcc']

match args:
    # 如果仅出现gcc，报错:
    case ['gcc']:
        print('gcc: missing source file(s).')
    # 出现gcc，且至少指定了一个文件:
    case ['gcc', file1, *files]:
        print('gcc compile: ' + file1 + ', ' + ', '.join(files))
    # 仅出现clean:
    case ['clean']:
        print('clean')
    case _:
        print('invalid command.')
```

### 循环语句

for name in names

while break continue



## 函数

### 函数参数

默认参数, add_end(L=[])的理由还未想明白

可变参数, `*nums`表示把`nums`这个list的所有元素作为可变参数传进去

关键字参数, `**kv`,在函数调用时自动组装为一个dict

参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。



`*args`是可变参数，args接收的是一个tuple；

`**kw`是关键字参数，kw接收的是一个dict。



装饰器

@decorator 等价于 func = decorator(func)，参照aop理解其概念和执行顺序

函数签名 wrapper(*args,**kw) 是个约定？

```python
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            return func(*args, **kw)

        return wrapper

    return decorator
```



## 高级特性

### 切片

`L[0:3]`表示，从索引`0`开始取，直到索引`3`为止，但不包括索引`3`。即索引`0`，`1`，`2`，正好是3个元素。



## 函数式

map(f, [x1, x2, x3, x4]) = f(x1),f(x2),f(x3),f(x4)

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map/reduce/filter	类比lambda.select/aggregate/where



闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量

关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数。

## 偏函数

偏函数（Partial function）有点类似于静态扩展方法

简单总结`functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
