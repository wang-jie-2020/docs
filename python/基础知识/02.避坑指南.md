



## 函数闭包陷阱

闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量

`nonlocal`: 用于嵌套函数中，声明外层函数的局部变量为非局部变量，使其可在内层函数中被修改。

`global`: 用于在函数内部声明全局变量，允许在函数内部修改全局作用域中的同名变量。



## 参数默认值的坑

函数参数的默认值是在定义时初始化的，而不是在运行时初始化的。

默认参数的坑, add_end(L=[])



## 生成式列表的坑

这种行为似乎和参数默认值很类似

```python
a = [None] * 2
print([id(i) for i in a])	# [140708600660288, 140708600660288]
a[0] = 1
print(a)					# [1, None]

b = [[None] * 2] * 3
print([id(i) for i in b])	# [2388733524288, 2388733524288, 2388733524288]
b[0] = [1, 1]
print(b)					# [[1, 1], [None, None], [None, None]]

c = [[None] * 2] * 3
print([id(i) for i in c])	# [2388733524544, 2388733524544, 2388733524544]
c[0][0] = 1					# [[1, None], [1, None], [1, None]]
print(c)

d = [[None] * 2 for _ in range(3)]	# [2388733523648, 2388733519488, 2388732361024]
print([id(i) for i in d])			# [[1, None], [None, None], [None, None]]
d[0][0] = 1
print(d)
```



