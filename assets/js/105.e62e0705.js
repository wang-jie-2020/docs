(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{429:function(t,v,_){"use strict";_.r(v);var a=_(4),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),v("p",[t._v("net、java")]),t._v(" "),v("p",[t._v("​\t对数据类型的划分基本一致,除了基本类型以及内建结构体外很少遇到新的值类型")]),t._v(" "),v("p",[t._v("​\t值类型、引用类型传递的理解一致,在一些描述中实际上都是"),v("code",[t._v("值")]),t._v("传递,"),v("code",[t._v("值")]),t._v("传递的意思是")]),t._v(" "),v("p",[t._v("​\t(1)值传递---copy"),v("code",[t._v("值")]),t._v("到新的栈地址,返回新的栈地址")]),t._v(" "),v("p",[t._v("​\t(2)引用类型---copy"),v("code",[t._v("堆地址")]),t._v("到新的栈地址,返回新的栈地址;==堆中存的子对象地址是共享的(不能完全肯定,写DEMO疑惑)==")]),t._v(" "),v("p",[t._v("​\tnet有ref、out可以实现真正意义上的引用传递")]),t._v(" "),v("p",[t._v("​\tjava似乎没有,只能进行引用包装")]),t._v(" "),v("p",[t._v("![[Drawing 2023-06-05.1.excalidraw|800*400]]")]),t._v(" "),v("p",[t._v("![[Drawing 2023-06-05.2.excalidraw|800*400]]")])])}),[],!1,null,null,null);v.default=e.exports}}]);