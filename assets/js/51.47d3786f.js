(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{371:function(e,a,s){"use strict";s.r(a);var t=s(4),p=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"对象映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象映射"}},[e._v("#")]),e._v(" 对象映射")]),e._v(" "),a("p",[e._v("Apache Commons BeanUtils")]),e._v(" "),a("p",[e._v("实现原理：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("反射机制：Apache Commons BeanUtils利用Java的反射API来访问和操作JavaBean的属性。它通过读取类的元信息（如字段、方法等）来动态地获取和设置对象的属性值。")])]),e._v(" "),a("li",[a("p",[e._v("属性复制：当使用"),a("code",[e._v("copyProperties")]),e._v("方法时，BeanUtils会遍历源对象的所有可读属性（即带有getter方法的属性），并尝试将这些属性的值设置到目标对象的对应属性中。这要求目标对象具有与源对象属性名相匹配的setter方法。")])]),e._v(" "),a("li",[a("p",[e._v("类型转换：BeanUtils还提供了类型转换功能，能够自动将一种类型的属性值转换为另一种类型，前提是这种转换是安全的和可接受的。")])]),e._v(" "),a("li",[a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" BeanUtils.copyProperties(personDTO, person);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])])]),e._v(" "),a("p",[e._v("Spring BeanUtils")]),e._v(" "),a("p",[e._v("实现原理：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("反射机制：同样基于Java反射API来实现属性复制。")])]),e._v(" "),a("li",[a("p",[e._v("属性匹配：通过比较源对象和目标对象的属性名（以及可能的属性类型），Spring BeanUtils将源对象的属性值复制到目标对象中。")])]),e._v(" "),a("li",[a("p",[e._v("Spring集成：由于它是Spring框架的一部分，因此可以无缝地与Spring的其他功能（如依赖注入）集成。")])]),e._v(" "),a("li",[a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("        BeanUtils.copyProperties(person, personDTO);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])])]),e._v(" "),a("p",[e._v("ModelMapper")]),e._v(" "),a("p",[e._v("实现原理：")]),e._v(" "),a("ul",[a("li",[e._v("约定优于配置：ModelMapper采用“约定优于配置”的原则，即它试图通过智能匹配源对象和目标对象的属性名来自动建立映射关系。")]),e._v(" "),a("li",[e._v("自定义映射：如果自动匹配不满足需求，开发者可以通过注解或编程方式定义自定义的映射规则。")]),e._v(" "),a("li",[e._v("类型转换：ModelMapper支持多种类型转换，并允许开发者注册自定义的类型转换器。")]),e._v(" "),a("li",[e._v("性能优化：ModelMapper在内部使用缓存和其他优化技术来提高映射性能。")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("        // 使用 ModelMapper 映射对象\n        PersonDTO personDTO = modelMapper.map(person, PersonDTO.class);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("MapStruct")]),e._v(" "),a("p",[e._v("定义：\nMapStruct是一个基于约定优于配置原则的Java注解处理器，用于生成类型安全的bean映射类。")]),e._v(" "),a("p",[e._v("实现原理：")]),e._v(" "),a("ul",[a("li",[e._v("注解处理器：MapStruct是一个Java注解处理器，它在编译时生成类型安全的映射代码。")]),e._v(" "),a("li",[e._v("注解定义：开发者在接口上使用MapStruct提供的注解（如"),a("code",[e._v("@Mapper")]),e._v("、"),a("code",[e._v("@Mapping")]),e._v("等）来定义映射规则。")]),e._v(" "),a("li",[e._v("编译时生成：在编译过程中，MapStruct注解处理器会扫描这些注解，并生成相应的映射实现类。这些实现类包含了将源对象映射到目标对象的具体逻辑。")]),e._v(" "),a("li",[e._v("性能优势：由于映射代码是在编译时生成的，因此MapStruct在运行时不依赖于反射，从而提高了映射性能。")]),e._v(" "),a("li",[e._v("类型安全：由于是编译时处理，MapStruct能够确保映射过程中的类型安全。")])])])}),[],!1,null,null,null);a.default=p.exports}}]);