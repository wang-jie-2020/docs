(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{440:function(t,e,s){"use strict";s.r(e);var r=s(4),c=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("作者：袁娅维十年铁粉")]),t._v(" "),e("p",[t._v("在添加功能的时候，尽量以开关的方式添加新的通路，一定要保证老通路能跑通。这实际上是敏捷开发中的 feature-flag 实践，在绝大多数情况下都是最佳实践。但是要记得，当代码稳定了之后，如果老通路不需要了，需要把相关代码都要删除，很少有人能做到这一点，因此欠下了很多技术债。")]),t._v(" "),e("p",[t._v("迭代是一个熵增的过程，最后代码总会变成一个大泥球，毫无高内聚低耦合等架构特征可言，单测、CI 混乱、严重影响迭代效率，此时需要对代码进行重构。一般也是新建一个代码库，不会基于老代码修修改改。新代码重构完毕之后，作为一个新的 service 上线，导入一些流量做 test，这也是非常好的实践。")]),t._v(" "),e("p",[t._v("新加的功能按照常理来说需要更改很多代码，于是采取一些取巧的 tricks 来减少代码量的修改，这是坏的。这会让上述 2 中，架构腐蚀的速度加快。如果实在着急上线也可以，tricks 可以作为短线救急方案，但是绝对不能把 tricks 当做一劳永逸的解决方案，事后需要考虑另一种优雅可靠、可长期存在的方案。")]),t._v(" "),e("p",[t._v("在做内核 / 编译器等基础架构升级的时候，由于需要批量更改一些代码（例如 "),e("code",[t._v("auto_ptr")]),t._v(" 等），秉持能跑就不更改的原则，放弃升级内核 / 编译器。毫无疑问，这也是坏的。更新编译器 / 内核的原因，一来是能够使用更新的技术，二来是为了保持代码库的生命力，就和打扫屋子一样。假如你一个代码库 close 了 27 年，再遇到紧急情况想迭代的时候，发现世界上已经没有  centos4 / gcc3 的环境了，想改都没法改。")]),t._v(" "),e("p",[t._v("原来代码写得比较差、没品位，于是修改成有品位的代码，例如把多个重载函数改成一个带各种约束的函数模板，把多个 if-else 改成表驱动。我不好说。如果有完善的测试，改改也可以，反正我不会这样改，在商业公司中做这种改动也属实罕见。")])])}),[],!1,null,null,null);e.default=c.exports}}]);