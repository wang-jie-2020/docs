(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{374:function(n,e,t){"use strict";t.r(e);var r=t(4),a=Object(r.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"泛型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[n._v("#")]),n._v(" 泛型")]),n._v(" "),e("h3",{attrs:{id:"_1-语法通配符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-语法通配符"}},[n._v("#")]),n._v(" 1.语法通配符")]),n._v("\n<?> 无限制通配符\n<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类\n<? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类\n\n```java\nprivate static "),n._v("<? super E>> E max(List<? extends E> e1) {\n    if (e1 == null) {\n        return null;\n    }\n    //迭代器返回的元素属于 E 的某个子类型\n    Iterator<? extends E> iterator = e1.iterator();\n    E result = iterator.next();\n    while (iterator.hasNext()) {\n        E next = iterator.next();\n        if (next.compareTo(result) > 0) {\n            result = next;\n        }\n    }\n\n    return result;\n}\n```\n\n### 2.泛型的擦除(Type Erasure)\n\n![img](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/java-basic-generic-1.png)\n\n\n\n![img](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/java-basic-generic-2.png)\n\n\n\n![img](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/java-basic-generic-3.png)\n\n### 3.泛型的桥接方法\n\n如果在泛型擦除的过程中存在类型的不一致，比如泛型"),e("T",[n._v("擦除到Object，但泛型类的实际类型被指定Date；\n\n形参不会从Object变为Date，而是重载方法签名；所以看似重写，底层却是重载（jvm）；\n\n### 4.参数类型\n\n```java\nArrayList"),e("String",[n._v(" genericType = new ArrayList"),e("String",[n._v("() {};\nType superclass = genericType.getClass().getGenericSuperclass();\nType type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\nSystem.out.println(type);//class java.lang.String\n```\n\n\n\n\n\n\n\n")])],1)],1)],1)}),[],!1,null,null,null);e.default=a.exports}}]);