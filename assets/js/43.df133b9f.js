(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{333:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"ioc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc"}},[t._v("#")]),t._v(" ioc")]),t._v(" "),e("h2",{attrs:{id:"一、bean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、bean"}},[t._v("#")]),t._v(" 一、Bean")]),t._v(" "),e("p",[t._v("bean配置的三种方式:(1)XML (2)JAVA配置 (3)注解")]),t._v(" "),e("p",[t._v("目前的主流方式是（3）+（2）配置：")]),t._v(" "),e("p",[t._v("​\t@Repository、@Service、@Controller、@Component")]),t._v(" "),e("p",[t._v("​\t@Configuration")]),t._v(" "),e("p",[t._v("以注解方式使用:")]),t._v(" "),e("p",[t._v("1、@Autowired是Spring自带的，@Resource是JSR250规范实现的，@Inject是JSR330规范实现的")]),t._v(" "),e("p",[t._v("2、@Autowired、@Inject用法基本一样，不同的是@Inject没有required属性")]),t._v(" "),e("p",[t._v("3、@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的")]),t._v(" "),e("p",[t._v("4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定")]),t._v(" "),e("p",[t._v("5、其他注解")]),t._v(" "),e("p",[t._v("​\t@Scope\t需要在类上使用注解 @Scope，其 value 属性用于指定作用域（singleton、"),e("strong",[t._v("prototype")]),t._v("、request）")]),t._v(" "),e("p",[t._v("​\t@Value\t需要在属性上使用注解 @Value，该注解的 value 属性用于指定要注入的值。")]),t._v(" "),e("p",[t._v("​\t@PostConstruct\t在方法上使用 @PostConstruct 相当于初始化")]),t._v(" "),e("h2",{attrs:{id:"二、上下文和容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、上下文和容器"}},[t._v("#")]),t._v(" 二、上下文和容器")]),t._v(" "),e("blockquote",[e("p",[t._v("Spring 配置文件中每一个"),e("bean",[t._v("节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。")])],1)]),t._v(" "),e("p",[e("strong",[t._v("BeanDefinition：各种Bean对象及其相互的关系")])]),t._v(" "),e("p",[e("strong",[t._v("BeanRegistry： 向IOC容器手工注册 BeanDefinition 对象的方法")])]),t._v(" "),e("p",[e("strong",[t._v("BeanFactory： 工厂模式定义了IOC容器的基本功能规范")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/spring-framework-ioc-source-2.png",alt:"img"}})]),t._v(" "),e("blockquote",[e("p",[t._v("IoC容器的接口类是ApplicationContext，很显然它必然继承BeanFactory对Bean规范（最基本的ioc容器的实现）进行定义。而ApplicationContext表示的是应用的上下文，除了对Bean的管理外，还至少应该包含了")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("访问资源")]),t._v("：对不同方式的Bean配置（即资源）进行加载。(实现ResourcePatternResolver接口)")]),t._v(" "),e("li",[e("strong",[t._v("国际化")]),t._v(": 支持信息源，可以实现国际化。（实现MessageSource接口）")]),t._v(" "),e("li",[e("strong",[t._v("应用事件")]),t._v(": 支持应用事件。(实现ApplicationEventPublisher接口)")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/spring-framework-ioc-source-71.png",alt:"img"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/spring-framework-ioc-source-51.png",alt:"img"}})]),t._v(" "),e("h2",{attrs:{id:"三、常见使用方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、常见使用方式"}},[t._v("#")]),t._v(" 三、常见使用方式")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("BeanFactoryPostProcessor（Bean的修改）")]),t._v(" "),e("p",[t._v("BeanDefinitionRegistryPostProcessor")]),t._v(" "),e("p",[t._v("BeanFactoryPostProcessor")])])]),t._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeanDefinitionRegistryPostProcessor")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeanFactoryPostProcessor")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("postProcessBeanDefinitionRegistry")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BeanDefinitionRegistry")]),t._v(" registry"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/5e70bcb4ff1d43b19da823fbc6e2a6d9.png",alt:"img"}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("InitializingBean（Bean实例化后触发执行方法）")]),t._v(" "),e("p",[t._v("实现InitializingBean接口并且重写afterPropertiesSet()，且bean要注册到Spring容器中，那么bean在实例化、属性注入后，重写的afterPropertiesSet()就会触发执行。")]),t._v(" "),e("p",[t._v("一个例子是在web项目中"),e("em",[t._v("Anonymous"),e("strong",[t._v("注解允许匿名访问的")]),t._v("url")]),t._v("(参见ruoyi PermitAllUrlProperties)")])]),t._v(" "),e("li",[e("p",[t._v("ApplicationContextAware")]),t._v(" "),e("p",[t._v("当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得 ApplicationContext 中的所有 bean。换句话说，就是这个类可以直接获取 Spring 配置文件中，所有有引用到的 Bean 对象。")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);