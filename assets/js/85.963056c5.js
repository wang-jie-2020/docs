(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{414:function(_,t,v){"use strict";v.r(t);var a=v(5),o=Object(a.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"一、-jbdc的事务管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、-jbdc的事务管理"}},[_._v("#")]),_._v(" 一、 JBDC的事务管理")]),_._v(" "),t("p",[_._v("大致翻过, 仍旧是一些隔离行为 和 事务范围的封装, 深入了解的意义不太大")]),_._v(" "),t("h2",{attrs:{id:"二、spring中的事务管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、spring中的事务管理"}},[_._v("#")]),_._v(" 二、Spring中的事务管理")]),_._v(" "),t("p",[_._v("新建的"),t("code",[_._v("Spring Boot")]),_._v("项目中，一般都会引用"),t("code",[_._v("spring-boot-starter")]),_._v("或者"),t("code",[_._v("spring-boot-starter-web")]),_._v("，而这两个起步依赖中都已经包含了对于"),t("code",[_._v("spring-boot-starter-jdbc")]),_._v("或"),t("code",[_._v("spring-boot-starter-data-jpa")]),_._v("的依赖。")]),_._v(" "),t("p",[_._v("当我们使用了这两个依赖的时候，框架会自动默认分别注入"),t("code",[_._v("DataSourceTransactionManager")]),_._v("或"),t("code",[_._v("JpaTransactionManager")]),_._v("。 所以我们不需要任何额外配置就可以用"),t("code",[_._v("@Transactional")]),_._v("注解进行事务的使用。")]),_._v(" "),t("blockquote",[t("p",[_._v("@Transactional注解只能应用到public可见度的方法上，可以被应用于接口定义和接口方法，方法会覆盖类上面声明的事务。")])]),_._v(" "),t("p",[_._v("因为"),t("code",[_._v("Spring")]),_._v("的默认的事务规则是遇到运行异常"),t("code",[_._v("（RuntimeException）")]),_._v("和程序错误"),t("code",[_._v("（Error）")]),_._v("才会回滚。如果想针对检查异常进行事务回滚，可以在"),t("code",[_._v("@Transactional")]),_._v("注解里使用 "),t("code",[_._v("rollbackFor")]),_._v("属性明确指定异常。如@Transactional(rollbackFor = Exception.class)")]),_._v(" "),t("p",[t("code",[_._v("Transactional")]),_._v("注解的常用属性表：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("属性")]),_._v(" "),t("th",[_._v("说明")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("propagation")]),_._v(" "),t("td",[_._v("事务的传播行为，默认值为 REQUIRED。")])]),_._v(" "),t("tr",[t("td",[_._v("isolation")]),_._v(" "),t("td",[_._v("事务的隔离度，默认值采用 DEFAULT")])]),_._v(" "),t("tr",[t("td",[_._v("timeout")]),_._v(" "),t("td",[_._v("事务的超时时间，默认值为-1，不超时。如果设置了超时时间(单位秒)，那么如果超过该时间限制了但事务还没有完成，则自动回滚事务。")])]),_._v(" "),t("tr",[t("td",[_._v("read-only")]),_._v(" "),t("td",[_._v("指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。")])]),_._v(" "),t("tr",[t("td",[_._v("rollbackFor")]),_._v(" "),t("td",[_._v("用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。{xxx1.class, xxx2.class,……}")])]),_._v(" "),t("tr",[t("td",[_._v("noRollbackFor")]),_._v(" "),t("td",[_._v("抛出 no-rollback-for 指定的异常类型，不回滚事务。{xxx1.class, xxx2.class,……}")])])])]),_._v(" "),t("blockquote",[t("p",[_._v("注意事项")]),_._v(" "),t("ul",[t("li",[_._v("同一个事务下是无法切换数据源")]),_._v(" "),t("li",[_._v("禁止父方法使用"),t("code",[_._v("@Transactional")]),_._v("创建事务，子方法使用"),t("code",[_._v("@DataSource")]),_._v("切换数据源")]),_._v(" "),t("li",[_._v("正确用法: 子方法单独创建事务或父方法使用"),t("code",[_._v("@Transactional(propagation = Propagation.REQUIRES_NEW)")]),_._v("为所有子方法创建新事务")])]),_._v(" "),t("p",[_._v("提示")]),_._v(" "),t("p",[_._v("事务的传播机制是指如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 即:在执行一个@Transactinal注解标注的方法时，开启了事务；当该方法还在执行中时，另一个人也触发了该方法；那么此时怎么算事务呢，这时就可以通过事务的传播机制来指定处理方式。")])]),_._v(" "),t("p",[t("code",[_._v("TransactionDefinition")]),_._v("传播行为的常量：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("常量")]),_._v(" "),t("th",[_._v("含义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_REQUIRED")]),_._v(" "),t("td",[_._v("如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。")])]),_._v(" "),t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_REQUIRES_NEW")]),_._v(" "),t("td",[_._v("创建一个新的事务，如果当前存在事务，则把当前事务挂起。")])]),_._v(" "),t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_SUPPORTS")]),_._v(" "),t("td",[_._v("如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。")])]),_._v(" "),t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_NOT_SUPPORTED")]),_._v(" "),t("td",[_._v("以非事务方式运行，如果当前存在事务，则把当前事务挂起。")])]),_._v(" "),t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_NEVER")]),_._v(" "),t("td",[_._v("以非事务方式运行，如果当前存在事务，则抛出异常。")])]),_._v(" "),t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_MANDATORY")]),_._v(" "),t("td",[_._v("如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。")])]),_._v(" "),t("tr",[t("td",[_._v("TransactionDefinition.PROPAGATION_NESTED")]),_._v(" "),t("td",[_._v("如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。")])])])]),_._v(" "),t("p",[_._v("Mybatis中有两种类型的事务管理器(type=JDBC|MANAGED):")]),_._v(" "),t("p",[_._v("​\tJDBC-这个配置直接使用了JDBC的提交和回滚功能，它依赖从数据源获得的连接来管理事务的作用域。默认情况下，在关闭连接时启用自动提交")]),_._v(" "),t("p",[_._v("​\tMANAGED-这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。默认情况下，它会关闭连接。")]),_._v(" "),t("p",[_._v("Spring会使用自带的事务管理器来覆盖mybatis自己的配置(覆盖配置,实际上仍旧时基于JDBC做的)。")]),_._v(" "),t("h2",{attrs:{id:"三、实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、实践"}},[_._v("#")]),_._v(" 三、实践")]),_._v(" "),t("p",[_._v("注意@Transactional注解的问题(和其他Aspect一样):")]),_._v(" "),t("ol",[t("li",[_._v("内部调用")]),_._v(" "),t("li",[_._v("静态方法、final类或方法、private方法")]),_._v(" "),t("li",[_._v("rollback 默认只针对RuntimeException")])])])}),[],!1,null,null,null);t.default=o.exports}}]);