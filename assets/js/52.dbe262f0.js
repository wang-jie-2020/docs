(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{373:function(t,v,e){"use strict";e.r(v);var _=e(4),a=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"lambda简述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda简述"}},[t._v("#")]),t._v(" lambda简述")]),t._v(" "),v("p",[t._v('比较java vs dotnet的实现意义不大,在查阅的资料中都会这么描述:"简化匿名函数"')]),t._v(" "),v("p",[t._v("两者的实现中的思路近似一致,不同的是ms对这块的封装更简化一些")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("Net")]),t._v(" "),v("th",[t._v("Java")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("delegate")]),t._v(" "),v("td",[t._v("FunctionalInterface")])]),t._v(" "),v("tr",[v("td",[t._v("Action"),v("in",{attrs:{T:""}})],1),t._v(" "),v("td",[t._v("Consumer"),v("T",[t._v(" ...")])],1)]),t._v(" "),v("tr",[v("td",[t._v("Func<in T,out R>")]),t._v(" "),v("td",[t._v("Supplier"),v("T",[t._v("、Function<T,R> ...")])],1)])])]),t._v(" "),v("p",[t._v("概括描述就是net以Action、Func的重载概括了必要的lambda形式,java这块提供了间接的")]),t._v(" "),v("p",[t._v("语法上稍有不同包括多播(运算符重载)、方法访问")]),t._v(" "),v("h3",{attrs:{id:"函数式接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数式接口"}},[t._v("#")]),t._v(" 函数式接口")]),t._v(" "),v("p",[t._v("只包含一个抽象方法的接口，称为"),v("strong",[t._v("函数式接口")])]),t._v(" "),v("p",[t._v("通常@FunctionalInterface注解")]),t._v(" "),v("h3",{attrs:{id:"内置的函数式接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内置的函数式接口"}},[t._v("#")]),t._v(" 内置的函数式接口")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("内置核心函数式接口")]),t._v(" "),v("th",[t._v("包含的方法")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Consumer"),v("T")],1),t._v(" "),v("td",[t._v("void accept(T t)")])]),t._v(" "),v("tr",[v("td",[t._v("BiConsumer<T, U>")]),t._v(" "),v("td",[t._v("void accept(T t, U u)")])]),t._v(" "),v("tr",[v("td",[t._v("Supplier"),v("T")],1),t._v(" "),v("td",[t._v("T get()")])]),t._v(" "),v("tr",[v("td",[t._v("Function<T,R>")]),t._v(" "),v("td",[t._v("R apply(T t)")])]),t._v(" "),v("tr",[v("td",[t._v("BiFunction<T, U, R>")]),t._v(" "),v("td",[t._v("R apply(T t, U u)")])]),t._v(" "),v("tr",[v("td",[t._v("Predicate"),v("T")],1),t._v(" "),v("td",[t._v("boolen test(T t)")])])])]),t._v(" "),v("h3",{attrs:{id:"语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" ::语法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("引用方式")]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("构造方法")]),t._v(" "),v("td",[t._v("ClassName:: staticMethodName")])]),t._v(" "),v("tr",[v("td",[t._v("静态方法")]),t._v(" "),v("td",[t._v("ClassName :: new")])]),t._v(" "),v("tr",[v("td",[t._v("任意实例方法")]),t._v(" "),v("td",[t._v("ClassName :: methodName")])]),t._v(" "),v("tr",[v("td",[t._v("指定实例方法")]),t._v(" "),v("td",[t._v("instance :: methodName")])])])]),t._v(" "),v("h2",{attrs:{id:"jcf-java-collections-framework"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jcf-java-collections-framework"}},[t._v("#")]),t._v(" JCF(Java Collections Framework)")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("接口名")]),t._v(" "),v("th",[t._v("Java8新加入的方法")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Collection")]),t._v(" "),v("td",[t._v("removeIf() spliterator() stream() parallelStream() forEach()")])]),t._v(" "),v("tr",[v("td",[t._v("List")]),t._v(" "),v("td",[t._v("replaceAll() sort()")])]),t._v(" "),v("tr",[v("td",[t._v("Map")]),t._v(" "),v("td",[t._v("getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()")])])])]),t._v(" "),v("h2",{attrs:{id:"stream"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stream"}},[t._v("#")]),t._v(" Stream")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/939998-20170313215540823-221594903.png",alt:"Java_stream_Interfaces"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("无存储")]),t._v("。"),v("em",[t._v("stream")]),t._v("不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。")]),t._v(" "),v("li",[v("strong",[t._v("为函数式编程而生")]),t._v("。对"),v("em",[t._v("stream")]),t._v("的任何修改都不会修改背后的数据源，比如对"),v("em",[t._v("stream")]),t._v("执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新"),v("em",[t._v("stream")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("惰式执行")]),t._v("。"),v("em",[t._v("stream")]),t._v("上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。")]),t._v(" "),v("li",[v("strong",[t._v("可消费性")]),t._v("。"),v("em",[t._v("stream")]),t._v("只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。")])]),t._v(" "),v("p",[t._v("对"),v("em",[t._v("stream")]),t._v("的操作分为为两类，"),v("strong",[t._v("中间操作(*intermediate operations*)和结束操作(*terminal operations*)")]),t._v("，二者特点是：")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("中间操作总是会惰式执行")]),t._v("，调用中间操作只会生成一个标记了该操作的新"),v("em",[t._v("stream")]),t._v("，仅此而已。")]),t._v(" "),v("li",[v("strong",[t._v("结束操作会触发实际计算")]),t._v("，计算发生时会把所有中间操作积攒的操作以"),v("em",[t._v("pipeline")]),t._v("的方式执行，这样可以减少迭代次数。计算完成之后"),v("em",[t._v("stream")]),t._v("就会失效。")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("操作类型")]),t._v(" "),v("th",[t._v("接口方法")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("中间操作")]),t._v(" "),v("td",[t._v("concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()")])]),t._v(" "),v("tr",[v("td",[t._v("结束操作")]),t._v(" "),v("td",[t._v("allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()")])])])]),t._v(" "),v("p",[v("em",[t._v("filter")]),t._v(" 函数原型为"),v("code",[t._v("Stream filter(Predicate predicate)")]),t._v("，作用是返回一个只包含满足"),v("code",[t._v("predicate")]),t._v("条件元素的"),v("code",[t._v("Stream")]),t._v("。")]),t._v(" "),v("p",[v("em",[t._v("map")]),t._v(" 函数原型为"),v("code",[t._v("Stream map(Function mapper)")]),t._v("，作用是返回一个对当前所有元素执行执行"),v("code",[t._v("mapper")]),t._v("之后的结果组成的"),v("code",[t._v("Stream")]),t._v("。直观的说，就是对每个元素按照某种操作进行转换，转换前后"),v("code",[t._v("Stream")]),t._v("中元素的个数不会改变，但元素的类型取决于转换之后的类型。")]),t._v(" "),v("p",[v("em",[t._v("reduce")]),t._v("操作可以实现从一组元素中生成一个值，"),v("code",[t._v("sum()")]),t._v("、"),v("code",[t._v("max()")]),t._v("、"),v("code",[t._v("min()")]),t._v("、"),v("code",[t._v("count()")]),t._v("等都是"),v("em",[t._v("reduce")]),t._v("操作，将他们单独设为函数只是因为常用。"),v("code",[t._v("reduce()")]),t._v("的方法定义有三种重写形式：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("Optional reduce(BinaryOperator accumulator)")])]),t._v(" "),v("li",[v("code",[t._v("T reduce(T identity, BinaryOperator accumulator)")])]),t._v(" "),v("li",[v("code",[t._v("U reduce(U identity, BiFunction accumulator, BinaryOperator combiner)")])])]),t._v(" "),v("p",[v("em",[t._v("collect")])]),t._v(" "),v("p",[v("code",[t._v("<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)")])]),t._v(" "),v("p",[v("code",[t._v("<R,A> R collect(Collector<? super T,A,R> collector)")])]),t._v(" "),v("ol",[v("li",[t._v("目标容器是什么？是"),v("em",[t._v("ArrayList")]),t._v("还是"),v("em",[t._v("HashSet")]),t._v("，或者是个"),v("em",[t._v("TreeMap")]),t._v("。")]),t._v(" "),v("li",[t._v("新元素如何添加到容器中？是"),v("code",[t._v("List.add()")]),t._v("还是"),v("code",[t._v("Map.put()")]),t._v("。")])]),t._v(" "),v("p",[t._v("如果并行的进行规约，还需要告诉"),v("em",[t._v("collect()")]),t._v(" 3. 多个部分结果如何合并成一个。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/939998-20170314192733276-1662918719.png",alt:"img"}})])])}),[],!1,null,null,null);v.default=a.exports}}]);