(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{390:function(e,a,t){"use strict";t.r(a);var n=t(4),s=Object(n.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"容器和上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容器和上下文"}},[e._v("#")]),e._v(" 容器和上下文")]),e._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),a("blockquote",[a("p",[e._v("Spring 配置文件中每一个"),a("bean",[e._v("节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。")])],1),e._v(" "),a("p",[e._v("IoC容器的接口类是ApplicationContext，很显然它必然继承BeanFactory对Bean规范（最基本的ioc容器的实现）进行定义。而ApplicationContext表示的是应用的上下文，除了对Bean的管理外，还至少应该包含了")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("访问资源")]),e._v("：对不同方式的Bean配置（即资源）进行加载。(实现ResourcePatternResolver接口)")]),e._v(" "),a("li",[a("strong",[e._v("国际化")]),e._v(": 支持信息源，可以实现国际化。（实现MessageSource接口）")]),e._v(" "),a("li",[a("strong",[e._v("应用事件")]),e._v(": 支持应用事件。(实现ApplicationEventPublisher接口)")])])]),e._v(" "),a("p",[a("strong",[e._v("BeanDefinition：各种Bean对象及其相互的关系")])]),e._v(" "),a("p",[a("strong",[e._v("BeanRegistry： 向IOC容器手工注册 BeanDefinition 对象的方法")])]),e._v(" "),a("p",[a("strong",[e._v("BeanFactory： 工厂模式定义了IOC容器的基本功能规范")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/spring-framework-ioc-source-71.png",alt:"img"}})]),e._v(" "),a("p",[a("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/image-20250722151214688.png",alt:"image-20250722151214688"}})]),e._v(" "),a("h2",{attrs:{id:"beanregistry-beanfactory-bean注册和bean工厂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beanregistry-beanfactory-bean注册和bean工厂"}},[e._v("#")]),e._v(" BeanRegistry & BeanFactory(Bean注册和Bean工厂)")]),e._v(" "),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/5e70bcb4ff1d43b19da823fbc6e2a6d9.png",alt:"img"}}),e._v(" "),a("p",[a("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/4961a9d23f81837712951a4208b196fb.png",alt:"img"}})]),e._v(" "),a("p",[a("em",[e._v("不出意外的情况下大概率不会对 BeanDefinitionReader->BeanRegistry 的过程有改动, 在二者的空隙间有两个插槽可以进行一定程度的修改:")])]),e._v(" "),a("p",[e._v("(1) BeanDefinitionRegistryPostProcessor")]),e._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BeanDefinitionRegistryPostProcessor")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BeanFactoryPostProcessor")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/**\n\t * Modify the application context's internal bean definition registry after its\n\t * standard initialization. All regular bean definitions will have been loaded,\n\t * but no beans will have been instantiated yet. This allows for adding further\n\t * bean definitions before the next post-processing phase kicks in.\n\t * @param registry the bean definition registry used by the application context\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("postProcessBeanDefinitionRegistry")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BeanDefinitionRegistry")]),e._v(" registry"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("throws")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BeansException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br")])]),a("p",[e._v("(2) BeanFactoryPostProcessor")]),e._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@FunctionalInterface")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BeanFactoryPostProcessor")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/**\n\t * Modify the application context's internal bean factory after its standard\n\t * initialization. All bean definitions will have been loaded, but no beans\n\t * will have been instantiated yet. This allows for overriding or adding\n\t * properties even to eager-initializing beans.\n\t * @param beanFactory the bean factory used by the application context\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("postProcessBeanFactory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ConfigurableListableBeanFactory")]),e._v(" beanFactory"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("throws")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BeansException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("h2",{attrs:{id:"bean-instantiate-bean实例化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bean-instantiate-bean实例化"}},[e._v("#")]),e._v(" Bean Instantiate(Bean实例化)")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wang-jie-2020/images/spring-framework-ioc-source-102.png",alt:"img"}})]),e._v(" "),a("p",[a("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/7e70ea485aff193dcdadace6e895242c.jpeg",alt:"img"}})]),e._v(" "),a("h3",{attrs:{id:"_1-实例化-bean"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-实例化-bean"}},[e._v("#")]),e._v(" 1 实例化 Bean")]),e._v(" "),a("p",[e._v("对于"),a("code",[e._v("BeanFactory")]),e._v("容器来说，当用户向容器请求一个尚未初始化的 Bean 或初始化 Bean 的时候，如果需要注入另一个尚未初始化的依赖，容器就会调用"),a("code",[e._v("createBean")]),e._v("进行实例化；对于"),a("code",[e._v("ApplicationContext")]),e._v("容器来说，当容器启动结束后，便实例化所有的 Bean。")]),e._v(" "),a("p",[e._v("容器通过获取"),a("code",[e._v("BeanDefinition")]),e._v("对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在"),a("code",[e._v("BeanWrapper")]),e._v("对象中，"),a("code",[e._v("BeanWrapper")]),e._v("提供了设置对象属性的接口，从而避免了使用反射机制设置属性。")]),e._v(" "),a("h3",{attrs:{id:"_2-设置对象属性-依赖注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-设置对象属性-依赖注入"}},[e._v("#")]),e._v(" 2 设置对象属性（依赖注入）")]),e._v(" "),a("p",[e._v("实例化后的对象被封装在"),a("code",[e._v("BeanWrapper")]),e._v("对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring 根据"),a("code",[e._v("BeanDefinition")]),e._v("中的信息进行依赖注入，并且通过"),a("code",[e._v("BeanWrapper")]),e._v("提供的设置属性的接口完成依赖注入。")]),e._v(" "),a("h3",{attrs:{id:"_3-注入-aware-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-注入-aware-接口"}},[e._v("#")]),e._v(" 3 注入 Aware 接口")]),e._v(" "),a("p",[e._v("紧接着，Spring 会检测该对象是否实现了"),a("code",[e._v("xxxAware")]),e._v("接口，并将相关的"),a("code",[e._v("xxxAware")]),e._v("实例注入给 Bean：")]),e._v(" "),a("ul",[a("li",[e._v("如果 Bean 实现了"),a("code",[e._v("BeanNameAware")]),e._v("接口，Spring 将 Bean 的 ID 传递给"),a("code",[e._v("setBeanName()")]),e._v("方法。实现"),a("code",[e._v("BeanNameAware")]),e._v("主要是为了通过 Bean 的引用来获得 Bean 的 ID，一般业务中是很少有用到 Bean 的 ID 的。")]),e._v(" "),a("li",[e._v("如果 Bean 实现了"),a("code",[e._v("BeanFactoryAware")]),e._v("接口，Spring 将调用"),a("code",[e._v("setBeanDactory(BeanFactory bf)")]),e._v("方法并把"),a("code",[e._v("BeanFactory")]),e._v("容器实例作为参数传入。实现"),a("code",[e._v("BeanFactoryAware")]),e._v("主要目的是为了获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等。")]),e._v(" "),a("li",[e._v("如果 Bean 实现了"),a("code",[e._v("ApplicationContextAware")]),e._v("接口，Spring 容器将调用"),a("code",[e._v("setApplicationContext(ApplicationContext ctx)")]),e._v("方法，把应用上下文作为参数传入，作用与"),a("code",[e._v("BeanFactory")]),e._v("类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用"),a("code",[e._v("setApplicationContext")]),e._v("方法时会把它自己作为"),a("code",[e._v("setApplicationContext")]),e._v("的参数传入，而 Spring 容器在调用"),a("code",[e._v("setBeanDactory")]),e._v("前需要程序员自己指定（注入）"),a("code",[e._v("setBeanDactory")]),e._v("里的参数"),a("code",[e._v("BeanFactory")]),e._v("。")])]),e._v(" "),a("h3",{attrs:{id:"_4-beanpostprocessor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-beanpostprocessor"}},[e._v("#")]),e._v(" 4 BeanPostProcessor")]),e._v(" "),a("p",[e._v("当经过上述几个步骤后，Bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过"),a("code",[e._v("BeanPostProcessor")]),e._v("接口实现。 该接口提供了两个函数：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("postProcessBeforeInitialzation(Object bean, String beanName)")]),e._v("当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会先于"),a("code",[e._v("InitialzationBean")]),e._v("执行，因此称为前置处理。 所有"),a("code",[e._v("Aware")]),e._v("接口的注入就是在这一步完成的。")]),e._v(" "),a("li",[a("code",[e._v("postProcessAfterInitialzation(Object bean, String beanName)")]),e._v("当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会在"),a("code",[e._v("InitialzationBean")]),e._v("完成后执行，因此称为后置处理。")])]),e._v(" "),a("h3",{attrs:{id:"_5-initializingbean-与-init-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-initializingbean-与-init-method"}},[e._v("#")]),e._v(" 5 InitializingBean 与 init-method")]),e._v(" "),a("p",[e._v("当"),a("code",[e._v("BeanPostProcessor")]),e._v("的前置处理完成后就会进入本阶段。 "),a("code",[e._v("InitializingBean")]),e._v("接口只有一个函数：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("afterPropertiesSet()")])])]),e._v(" "),a("p",[e._v("这一阶段也可以在 Bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 Bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让 Bean 实现该接口，并把要增加的逻辑写在该函数中。然后，Spring 会在前置处理完成后检测当前 Bean 是否实现了该接口，并执行"),a("code",[e._v("afterPropertiesSet")]),e._v("函数。")]),e._v(" "),a("p",[e._v("当然，Spring 为了降低对客户代码的侵入性，给 Bean 的配置提供了"),a("code",[e._v("init-method")]),e._v("属性，该属性指定了在这一阶段需要执行的函数名。Spring 便会在初始化阶段执行我们设置的函数。"),a("code",[e._v("init-method")]),e._v("本质上仍然使用了"),a("code",[e._v("InitializingBean")]),e._v("接口。")]),e._v(" "),a("p",[a("em",[e._v("init-method 目前理解是通过xml配置bean时的一个用法,类似的还是destory")])]),e._v(" "),a("h3",{attrs:{id:"_6-disposablebean-和-destroy-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-disposablebean-和-destroy-method"}},[e._v("#")]),e._v(" 6 DisposableBean 和 destroy-method")]),e._v(" "),a("p",[e._v("如果 Bean 实现了"),a("code",[e._v("DispostbleBean")]),e._v("接口，Spring 将调用它的"),a("code",[e._v("destory")]),e._v("方法，作用与在配置文件中对 Bean 使用"),a("code",[e._v("destory-method")]),e._v("属性的作用一样，都是在 Bean 实例销毁前执行的方法。")]),e._v(" "),a("h3",{attrs:{id:"一些理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些理解"}},[e._v("#")]),e._v(" 一些理解")]),e._v(" "),a("p",[e._v("(1) BeanDefinition -> Registry -> Factory -> BeanInstance, 其中的过程有提供一些覆写")]),e._v(" "),a("p",[e._v("​\tRegistry、Factory -> BeanDefinitionRegistryPostProcessor")]),e._v(" "),a("p",[e._v("​\tBeanInstance -> BeanPostProcessor、InitializingBean、@PostConstruct")]),e._v(" "),a("p",[e._v("(2) "),a("strong",[e._v("对于"),a("code",[e._v("ApplicationContext")]),e._v("容器来说，当容器启动结束后，便实例化所有的 Bean")])]),e._v(" "),a("h2",{attrs:{id:"bean-配置注解和使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bean-配置注解和使用"}},[e._v("#")]),e._v(" Bean 配置注解和使用")]),e._v(" "),a("p",[e._v("Bean 配置的三种方式:(1)XML (2)JAVA配置 (3)注解")]),e._v(" "),a("p",[e._v("目前的主流方式是（3）+（2）配置")]),e._v(" "),a("p",[e._v("​\t注解方式：Repository、Service、Controller、Component")]),e._v(" "),a("p",[e._v("​\tJAVA配置：Configuration & Bean")]),e._v(" "),a("p",[e._v("通过注解方式使用:")]),e._v(" "),a("p",[e._v("1、@Autowired是Spring自带的，@Resource是JSR250规范实现的，@Inject是JSR330规范实现的")]),e._v(" "),a("p",[e._v("2、@Autowired、@Inject用法基本一样，不同的是@Inject没有required属性")]),e._v(" "),a("p",[e._v("3、@Autowired、@Inject是默认按照"),a("strong",[e._v("类型")]),e._v("匹配的，@Resource是按照"),a("strong",[e._v("名称")]),e._v("匹配的")]),e._v(" "),a("p",[e._v("4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定")]),e._v(" "),a("p",[e._v("5、其他注解")]),e._v(" "),a("p",[e._v("​\t@Scope\t需要在类上使用注解 @Scope，其 value 属性用于指定作用域（singleton、"),a("strong",[e._v("prototype")]),e._v("、request）")]),e._v(" "),a("p",[e._v("​\t@Value\t需要在属性上使用注解 @Value，该注解的 value 属性用于指定要注入的值。")]),e._v(" "),a("p",[e._v("​\t@PostConstruct\t在方法上使用 @PostConstruct 相当于初始化")])])}),[],!1,null,null,null);a.default=s.exports}}]);