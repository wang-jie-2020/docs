(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{390:function(a,t,p){"use strict";p.r(t);var e=p(4),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"adapter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#adapter"}},[a._v("#")]),a._v(" adapter")]),a._v(" "),t("p",[a._v("适配模式,指的是新的接口通过适配器访问原有接口,保持尽可能少的修改变更.")]),a._v(" "),t("p",[a._v("业务场景中很少尝试,原因是大多数情况对api的调用封装只会考虑到一层,例如以api包装或者helper处理,但实际上这两类方式不一定完全符合设计约束,或者说基本不符合程序设计思路")]),a._v(" "),t("p",[a._v("可参考的实例是基于autofac-castle-dynamicProxy的castle-core-asyncInterceptor的abp封装,这里主要梳理逻辑而不是代码示例.")]),a._v(" "),t("p",[a._v("按示例代码逻辑梳理出来的调用过程:")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("adapter 入口")]),a._v(" "),t("p",[a._v("继承或实现组件接口,实现泛型注入(通常为构造函数继承重写)")])]),a._v(" "),t("li",[t("p",[a._v("adapter 调用")]),a._v(" "),t("p",[a._v("在入口组件中对核心调用过程重构.通过1个或多个适配器组织参数或者方法调用,同时注入自己的逻辑处理和自己的逻辑参数,替换或者追加")])]),a._v(" "),t("li",[t("p",[a._v("adapter 参数")]),a._v(" "),t("p",[a._v("如非必要,简单类型参数还是尽量包装,非简单类型的参数还是通过适配过程更合适")]),a._v(" "),t("p",[a._v("在适配过程中甚至可以插入新的代码逻辑函数委托")])])]),a._v(" "),t("p",[a._v("最终过程是以原组件注册-触发->进入重写的入口实现->进入adapter中的新逻辑和方法,同时传递原接口必要信息->调用adapter方法")])])}),[],!1,null,null,null);t.default=r.exports}}]);