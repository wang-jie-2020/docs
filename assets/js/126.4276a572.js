(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{448:function(_,t,a){"use strict";a.r(t);var v=a(4),r=Object(v.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。")]),_._v(" "),t("p",[_._v("Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）")]),_._v(" "),t("p",[_._v("CAP：一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）")]),_._v(" "),t("p",[_._v("BASE：Basically Available(基本可用)、Soft state（软状态）、Eventually consistent（最终一致性）")]),_._v(" "),t("h2",{attrs:{id:"_2pc-xa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2pc-xa"}},[_._v("#")]),_._v(" 2PC/XA")]),_._v(" "),t("p",[_._v("2PC 要解决的问题可以简单总结为：在分布式系统中，每个节点虽然可以知道自己的操作是成功还是失败，却是无法知道其他节点的操作状态。当一个事务需要跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为"),t("strong",[_._v("协调者")]),_._v("的组件来统一掌控所有节点（参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： "),t("strong",[_._v("参与者将操作结果通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/2pc_process.png",alt:"两阶段提交过程"}})]),_._v(" "),t("h3",{attrs:{id:"提交请求阶段-投票阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提交请求阶段-投票阶段"}},[_._v("#")]),_._v(" 提交请求阶段(投票阶段)")]),_._v(" "),t("p",[_._v("第一阶段也被称作"),t("strong",[_._v("投票阶段")]),_._v("，即各参与者投票是否要继续接下来的提交操作")]),_._v(" "),t("ol",[t("li",[_._v("协调者节点向所有参与者节点询问是否可以执行提交操作（"),t("code",[_._v("QUERY TO COMMIT")]),_._v("），并开始等待各参与者节点的响应。")]),_._v(" "),t("li",[_._v("参与者节点执行询问发起为止的所有事务操作，并将undo信息和redo信息写入日志("),t("a",{attrs:{href:"https://segmentfault.com/a/1190000018058484",target:"_blank",rel:"noopener noreferrer"}},[_._v("预写式日志"),t("OutboundLink")],1),_._v(")。")]),_._v(" "),t("li",[_._v('各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个"同意"('),t("code",[_._v("YES")]),_._v(')消息；如果参与者节点的事务操作实际执行失败，则它返回一个"中止"('),t("code",[_._v("NO")]),_._v(")消息")])]),_._v(" "),t("h3",{attrs:{id:"提交执行阶段-执行阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提交执行阶段-执行阶段"}},[_._v("#")]),_._v(" 提交执行阶段(执行阶段)")]),_._v(" "),t("p",[_._v("第二阶段也被称作完成阶段，因为无论结果怎样，协调者都必须在此阶段结束当前事务。")]),_._v(" "),t("p",[_._v("成功")]),_._v(" "),t("p",[_._v('当协调者节点从所有参与者节点获得的相应消息都为"同意"时：')]),_._v(" "),t("ol",[t("li",[_._v('协调者节点向所有参与者节点发出"正式提交"('),t("code",[_._v("COMMIT")]),_._v(")的请求。")]),_._v(" "),t("li",[_._v("参与者节点正式完成操作，并释放在整个事务期间内占用的资源。")]),_._v(" "),t("li",[_._v('参与者节点向协调者节点发送"完成"('),t("code",[_._v("ACKNOWLEDGMENT")]),_._v(")消息。")]),_._v(" "),t("li",[_._v('协调者节点收到所有参与者节点反馈的"完成"消息后，完成事务。')])]),_._v(" "),t("p",[_._v("失败")]),_._v(" "),t("p",[_._v('如果任一参与者节点在第一阶段返回的响应消息为"终止"，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：')]),_._v(" "),t("ol",[t("li",[_._v('协调者节点向所有参与者节点发出"回滚操作"(ROLLBACK)的请求。')]),_._v(" "),t("li",[_._v("参与者节点利用之前写入的undo信息执行回滚，并释放在整个事务期间内占用的资源。")]),_._v(" "),t("li",[_._v('参与者节点向协调者节点发送"回滚完成"('),t("code",[_._v("ACKNOWLEDGMENT")]),_._v(")消息。")]),_._v(" "),t("li",[_._v('协调者节点收到所有参与者节点反馈的"回滚完成"消息后，取消事务。')])]),_._v(" "),t("h3",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[_._v("#")]),_._v(" 优缺点")]),_._v(" "),t("ul",[t("li",[_._v("优点：原理简洁清晰、实现方便；")]),_._v(" "),t("li",[_._v("缺点：同步阻塞、单点问题、某些情况可能导致数据不一致。")])]),_._v(" "),t("h2",{attrs:{id:"_3pc-了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3pc-了解"}},[_._v("#")]),_._v(" 3PC(了解)")]),_._v(" "),t("p",[_._v("三阶段提交协议（Three-Phase Commit， 3PC）最关键要解决的就是 Coordinator 和参与者同时挂掉导致数据不一致的问题，所以 3PC 把在 2PC 中又添加一个阶段，这样三阶段提交就有：CanCommit、PreCommit 和 DoCommit 三个阶段。")]),_._v(" "),t("h3",{attrs:{id:"阶段一-cancommit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阶段一-cancommit"}},[_._v("#")]),_._v(" 阶段一 CanCommit")]),_._v(" "),t("ol",[t("li",[_._v("事务询问：Coordinator 向各参与者发送 CanCommit 的请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应；")]),_._v(" "),t("li",[_._v("参与者向 Coordinator 反馈询问的响应：参与者收到 CanCommit 请求后，正常情况下，如果自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No。")])]),_._v(" "),t("h3",{attrs:{id:"阶段二-precommit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阶段二-precommit"}},[_._v("#")]),_._v(" 阶段二 PreCommit")]),_._v(" "),t("p",[t("strong",[_._v("执行事务预提交")]),_._v("：如果 Coordinator 接收到各参与者反馈都是Yes，那么执行事务预提交：")]),_._v(" "),t("ol",[t("li",[_._v("发送预提交请求：Coordinator 向各参与者发送 preCommit 请求，并进入 prepared 阶段；")]),_._v(" "),t("li",[_._v("事务预提交：参与者接收到 preCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日记中；")]),_._v(" "),t("li",[_._v("各参与者向 Coordinator 反馈事务执行的响应：如果各参与者都成功执行了事务操作，那么反馈给协调者 ACK 响应，同时等待最终指令，提交 commit 或者终止 abort，结束流程；")])]),_._v(" "),t("p",[t("strong",[_._v("中断事务")]),_._v("：如果任何一个参与者向 Coordinator 反馈了 No 响应，或者在等待超时后，Coordinator 无法接收到所有参与者的反馈，那么就会中断事务。")]),_._v(" "),t("ol",[t("li",[_._v("发送中断请求：Coordinator 向所有参与者发送 abort 请求；")]),_._v(" "),t("li",[_._v("中断事务：无论是收到来自 Coordinator 的 abort 请求，还是等待超时，参与者都中断事务。")])]),_._v(" "),t("h3",{attrs:{id:"阶段三-docommit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阶段三-docommit"}},[_._v("#")]),_._v(" 阶段三 doCommit")]),_._v(" "),t("p",[t("strong",[_._v("执行提交")])]),_._v(" "),t("ol",[t("li",[_._v("发送提交请求：假设 Coordinator 正常工作，接收到了所有参与者的 ack 响应，那么它将从预提交阶段进入提交状态，并向所有参与者发送 doCommit 请求；")]),_._v(" "),t("li",[_._v("事务提交：参与者收到 doCommit 请求后，正式提交事务，并在完成事务提交后释放占用的资源；")]),_._v(" "),t("li",[_._v("反馈事务提交结果：参与者完成事务提交后，向 Coordinator 发送 ACK 信息；")]),_._v(" "),t("li",[_._v("完成事务：Coordinator 接收到所有参与者 ack 信息，完成事务。")])]),_._v(" "),t("p",[t("strong",[_._v("中断事务")]),_._v("：假设 Coordinator 正常工作，并且有任一参与者反馈 No，或者在等待超时后无法接收所有参与者的反馈，都会中断事务")]),_._v(" "),t("ol",[t("li",[_._v("发送中断请求：Coordinator 向所有参与者节点发送 abort 请求；")]),_._v(" "),t("li",[_._v("事务回滚：参与者接收到 abort 请求后，利用 undo 日志执行事务回滚，并在完成事务回滚后释放占用的资源；")]),_._v(" "),t("li",[_._v("反馈事务回滚结果：参与者在完成事务回滚之后，向 Coordinator 发送 ack 信息；")]),_._v(" "),t("li",[_._v("中断事务：Coordinator 接收到所有参与者反馈的 ack 信息后，中断事务。")])]),_._v(" "),t("h3",{attrs:{id:"优缺点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点-2"}},[_._v("#")]),_._v(" 优缺点")]),_._v(" "),t("p",[_._v("3PC 虽然解决了 Coordinator 与参与者都异常情况下导致数据不一致的问题，3PC 依然带来其他问题：比如，网络分区问题，在 preCommit 消息发送后突然两个机房断开，这时候 Coordinator 所在机房会 abort, 另外剩余参与者的机房则会 commit。")]),_._v(" "),t("p",[_._v("而且由于3PC 的设计过于复杂，在解决2PC 问题的同时也引入了新的问题，所以在实际上应用不是很广泛。")]),_._v(" "),t("h3",{attrs:{id:"saga"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#saga"}},[_._v("#")]),_._v(" SAGA")]),_._v(" "),t("p",[_._v("其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/bVcTlFy",alt:"image.png"}})]),_._v(" "),t("p",[_._v("Saga事务的特点：")]),_._v(" "),t("ul",[t("li",[_._v("并发度高，不用像XA事务那样长期锁定资源")]),_._v(" "),t("li",[_._v("需要定义正常操作以及补偿操作，开发量比XA大")]),_._v(" "),t("li",[_._v("一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况")])]),_._v(" "),t("h2",{attrs:{id:"tcc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcc"}},[_._v("#")]),_._v(" TCC")]),_._v(" "),t("p",[_._v("TCC（"),t("code",[_._v("Try-Confirm-Cancel")]),_._v("） 实际上是服务化的两阶段提交协议。TCC分为3个阶段")]),_._v(" "),t("ul",[t("li",[_._v("Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）")]),_._v(" "),t("li",[_._v("Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。")]),_._v(" "),t("li",[_._v("Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。")])]),_._v(" "),t("p",[_._v("TCC特点如下：")]),_._v(" "),t("ul",[t("li",[_._v("并发度较高，无长期资源锁定。")]),_._v(" "),t("li",[_._v("开发量较大，需要提供Try/Confirm/Cancel接口。")]),_._v(" "),t("li",[_._v("一致性较好，不会发生SAGA已扣款最后又转账失败的情况")]),_._v(" "),t("li",[_._v("TCC适用于订单类业务，对中间状态有约束的业务")])]),_._v(" "),t("h2",{attrs:{id:"本地消息表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地消息表"}},[_._v("#")]),_._v(" 本地消息表")]),_._v(" "),t("p",[_._v("设计核心是将需要分布式处理的任务通过消息的方式来异步确保执行。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/bVcTlFE",alt:"image.png"}})]),_._v(" "),t("p",[_._v("本地消息表的特点：")]),_._v(" "),t("ul",[t("li",[_._v("不支持回滚")]),_._v(" "),t("li",[_._v("轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难")])]),_._v(" "),t("h2",{attrs:{id:"事务消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务消息"}},[_._v("#")]),_._v(" 事务消息")]),_._v(" "),t("p",[_._v("在上述的本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重。阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.gitcode.com/qq_36179938/images/raw/main/bVcXNbU",alt:"image.png"}})]),_._v(" "),t("p",[_._v("事务消息特点如下：")]),_._v(" "),t("ul",[t("li",[_._v("长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单")]),_._v(" "),t("li",[_._v("事务消息的回查没有好的方案，极端情况可能出现数据错误")])]),_._v(" "),t("h2",{attrs:{id:"最大努力通知"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最大努力通知"}},[_._v("#")]),_._v(" 最大努力通知")]),_._v(" "),t("p",[_._v("发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。")]),_._v(" "),t("p",[_._v("最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。")]),_._v(" "),t("p",[_._v("解决方案上，最大努力通知需要：")]),_._v(" "),t("ul",[t("li",[_._v("提供接口，让接受通知放能够通过接口查询业务处理结果")]),_._v(" "),t("li",[_._v("消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知")])]),_._v(" "),t("h2",{attrs:{id:"at模式-auto-transcation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#at模式-auto-transcation"}},[_._v("#")]),_._v(" AT模式（auto transcation）")]),_._v(" "),t("p",[_._v("​\tAT 模式是一种无侵入的分布式事务解决方案，阿里的Seata框架，实现了该模式。在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段进行提交和回滚操作。")])])}),[],!1,null,null,null);t.default=r.exports}}]);