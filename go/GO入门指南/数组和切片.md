# 数组和切片

## 数组

数组声明 `var identifier [len]type`

数组是==值==类型,这意味着传递数组时会有比较不同

> 如果函数需要操作数组,那么可能总是以切片表示更好?

==todo== 通过`&`传递数组引用不需要再通过`*`转换? `例7.6 array_sum.go`

## 切片

切片声明 `var identifier []type`



切片是引用类型,更加类似于其他语言中的集合,它是数组的一个连续片段的引用

​	`var slice1 []type = arr1[start:end]`	

​	slice1是由数组arr1从 `start` 索引到 ==end-1== 索引之间的元素构成的子集

切片的长度 `len()`

切片的容量 `cap()` --- 切片的长度 + 数组除切片之外的长度,也就是从 `start` 索引到数组末尾

切片可以调整大小(切片重组 **reslicing**),但必须满足新的start索引 >= 之前的start索引



`make()` 初始化切片,方法签名：`func make([]T, len, cap)`，其中 `cap` 是可选参数

​	`make([]int, 50, 100)  ==  new([100]int)[0:50]`

​	==todo== new() 和 make() 的区别有什么很大的影响?



> `func copy(dst, src []T) int` 方法将类型为 `T` 的切片从源地址 `src` 拷贝到目标地址 `dst`，覆盖 `dst` 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 `src` 和 `dst` 的长度最小值。如果 `src` 是字符串那么元素类型就是 `byte`。如果你还想继续使用 `src`，在拷贝结束后执行 `src = dst`。
>
> 
>
> `func append(s[]T, x ...T) []T` 其中 `append()` 方法将 0 个或多个具有相同类型 `s` 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素是同类型。如果 `s` 的容量不足以存储新增元素，`append()` 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。`append()` 方法总是返回成功，除非系统内存耗尽了。





```go
for ix, value := range slice1 {
	...
}
```

第一个返回值 `ix` 是数组或者切片的索引，第二个是在该索引位置的值；他们都是仅在 `for` 循环内部可见的局部变量。`value` 只是 `slice1` 某个索引位置的值的一个拷贝，不能用来修改 `slice1` 该索引位置的值。

