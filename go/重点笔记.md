# 重点笔记

## 环境和命令

go env -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct

## 基本

1. var 以及 :=

2. 常量 iota

3. if

   if initialization; condition {} 

4. switch

   break ×  

   continue √ 

   return √

   

   switch 任意类型 | 初始化语句; | 省略

   ​	case 一行一值 | 一行多值 | bool表达式(省略时) 

   ​	空case 不执行

   ​	fallthrough 流向下一个忽略条件

5. for

​	for 初始化语句; 条件语句; 修饰语句 {}

​	for-range：for ix, **val** := range list { } **val始终是值拷贝**

## 函数

- main、init


![image-20230825154442125](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/image-20230825154442125.png)

- defer

  释放资源

  recover

  多个defer函数按照LIFO

  return前执行，循环体defer不可取

- panic 和 recover

## 数组和切片

var identifier [len]type	这是数组,数组是值类型

var identifier []type		这是切片,切片是引用类型



切片是数组的子集,从 `start` 索引到 ==end-1== 索引之间的元素构成的子集

s := arr[startIndex:endIndex]	startIndex -> endIndex-1

​	len() --- 切片的长度

​	cap() --- 切片的容量,切片的长度 + 数组除切片之外的长度

**make() 创建一个切片**

​	make([]T, length, capacity) 

​	make([]int, 50, 100) == new([100]int)[0:50]

**追加和复制切片**

​	`func append(s[]T, x ...T) []T`

​	`func copy(dst, src []T) int`

## Map

var identifier map[keytype]valuetype	键值对

**make() 创建一个Map**

​	make(map[int]string, 10),capacity可以省略	

## 结构和方法

对象 = 结构 + 结构方法

结构：普通字段、匿名字段、内嵌结构体---继承

结构方法：接收者类型是结构和结构指针---继承

## 接口

接口

空接口(视作object)

接口可以被多个类型实现---多态

​	类型断言	逗号ok 模式

​	类型断言	type-switch 模式

接口方法

​	不存在类似结构的自动解指针，必须对应一致

## ★协程和信道

GO协程类似于C#的Task,实际效果有些类似Csharp的线程池以及线程调度.

信道的发送和接收都是**原子**操作,操作符<-

​	ch <- int1

​	int2 = <- ch

非缓冲信道要求必须两端存在否则阻塞；若不需阻塞行为则定义带缓冲区的信道

ch := make(chan type, value)



通道的方向可以指定,只读或者只写,它是一个语法而不是新的东西

close() 关闭信道,检查状态使用逗号ok模式 v, ok := <-ch，for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭

select 模式切换协程

```go
select {
    case <- chan1:
        // 如果chan1成功读到数据，则进行该case处理语句
    case chan2 <- 1:
        // 如果成功向chan2写入数据，则进行该case处理语句
    default:
        // 如果上面都没有成功，则进入default处理流程
}
```

## ★Web

### tcp

```go
listener, err := net.Listen("tcp", "localhost:50000")
for {
	conn, err := listener.Accept()
    go doServerStuff(conn)
}

func doServerStuff(conn net.Conn) {
    for {
        buf := make([]byte, 512)
		len, err := conn.Read(buf)
    }
}



conn, err := net.Dial("tcp", "localhost:50000")
_, err = conn.Write([]byte("hello"))	//写,io.WriteString(conn, msg)?
for read {								//读
    count, err = con.Read(data)
    read = (err == nil)
    fmt.Printf(string(data[0:count]))
}
```

### net/http

![image-20230822174610913](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/image-20230822174610913.png)

![image-20230822174627735](https://cdn.jsdelivr.net/gh/wang-jie-2020/images/image-20230822174627735.png)

```go
//方式一
http.HandleFunc("/", HelloServer)	
err := http.ListenAndServe(":8080", nil)

//方式二
err := http.ListenAndServe(":8080", http.HandlerFunc(HelloServer))

//方式三 实现了Handler接口的对象
err := http.ListenAndServe(":8080", http.Handle("/", obj))	*
```
